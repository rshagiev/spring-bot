🧠 Python Project Dump for LLM — spring-bot
📅 Date: Wed Jul  9 18:11:00 +05 2025
📂 Path: /Users/rshagiev/PycharmProjects/spring-bot
==============================================


📁 Project Structure (tree -L 3):
----------------------------------------------
.
├── backtest_runner.py
├── bybit_wrapper.py
├── check_keys.py
├── dashboard.py
├── db_setup.py
├── db_utils.py
├── dump_python_files.sh
├── main.py
├── models.py
├── position_manager.py
├── project_dump.txt
├── README.md
├── requirements.txt
├── risk_controls.py
├── risk_sizer.py
├── signal_parser.py
├── spring_model.py
├── tests
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_api_process_signal.py
│   ├── test_backtest_runner.py
│   ├── test_bybit_wrapper.py
│   ├── test_position_manager.py
│   ├── test_risk_controls.py
│   ├── test_risk_sizer.py
│   ├── test_signal_parser.py
│   ├── test_spring_model.py
│   └── test_trade_logger.py
├── trade_logger.py
├── trades.sqlite
├── trades.sqlite-shm
└── trades.sqlite-wal

2 directories, 32 files


📦 requirements.txt:
----------------------------------------------
# Core Logic & Data
pandas
numpy

# API & Web Services
fastapi
uvicorn
aiofiles

# Exchange Integration
ccxt==4.*

# Database
sqlite-utils==3.*

# Testing
pytest
pytest-asyncio
pytest-mock
httpx 

# UI & Dashboard
streamlit
streamlit-autorefresh
python-dotenv

📝 Python Files:
==============================================


🔹 File: backtest_runner.py
----------------------------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from itertools import product
from spring_model import bounce_prob

# --- Constants ---
INITIAL_EQUITY = 1000.0
RISK_PER_TRADE_PCT = 0.01
FIXED_RR_RATIO = 1.5
PROB_THRESHOLD = 0.5

def run_backtest(price_df, signals_df, bb_window, bb_std_dev):
    equity = INITIAL_EQUITY
    equity_curve = [INITIAL_EQUITY]
    trades = []

    for _, signal in signals_df.iterrows():
        # Find the price data available right before the signal
        bars = price_df[price_df['ts'] < signal['ts']].tail(bb_window)
        if len(bars) < bb_window:
            continue

        # 1. Filter signal through the spring model
        prob = bounce_prob(bars, signal['side'], signal['entry'], bb_window, bb_std_dev)
        if prob < PROB_THRESHOLD:
            continue

        # 2. Size the trade
        risk_per_trade_usd = equity * RISK_PER_TRADE_PCT
        stop_loss_dist = abs(signal['entry'] - signal['sl'])
        if stop_loss_dist == 0: continue
        position_size = risk_per_trade_usd / stop_loss_dist

        # 3. Determine TP based on fixed R:R
        take_profit_dist = stop_loss_dist * FIXED_RR_RATIO
        if signal['side'] == 'long':
            tp_price = signal['entry'] + take_profit_dist
            sl_price = signal['sl']
        else:
            tp_price = signal['entry'] - take_profit_dist
            sl_price = signal['sl']

        # 4. Simulate trade execution
        trade_data = price_df[price_df['ts'] >= signal['ts']]
        pnl = 0
        outcome = 'No fill'
        for _, row in trade_data.iterrows():
            if signal['side'] == 'long':
                if row['high'] >= tp_price:
                    pnl = (tp_price - signal['entry']) * position_size
                    outcome = 'TP'
                    break
                if row['low'] <= sl_price:
                    pnl = (sl_price - signal['entry']) * position_size
                    outcome = 'SL'
                    break
            else: # short
                if row['low'] <= tp_price:
                    pnl = (signal['entry'] - tp_price) * position_size
                    outcome = 'TP'
                    break
                if row['high'] >= sl_price:
                    pnl = (signal['entry'] - sl_price) * position_size
                    outcome = 'SL'
                    break

        if outcome in ['TP', 'SL']:
            equity += pnl
            equity_curve.append(equity)
            trades.append({'pnl': pnl, 'outcome': outcome})
    
    return equity_curve, trades

def calculate_metrics(equity_curve, num_days):
    returns = pd.Series(equity_curve).pct_change().dropna()
    total_return = (equity_curve[-1] / INITIAL_EQUITY) - 1
    
    # Max Drawdown
    rolling_max = pd.Series(equity_curve).cummax()
    drawdown = (pd.Series(equity_curve) - rolling_max) / rolling_max
    max_drawdown = drawdown.min()
    
    # Sharpe Ratio (annualized)
    daily_returns = returns[returns != 0]
    if len(daily_returns) > 1 and daily_returns.std() != 0:
        # NOTE: This is an approximate annualization, assuming trades are somewhat evenly distributed.
        # It's suitable for comparing parameters but is not a perfectly rigorous Sharpe calculation.
        sharpe_ratio = (daily_returns.mean() / daily_returns.std()) * np.sqrt(365 * 24 * 60 / (num_days * 24 * 60 / len(daily_returns)) )
    else:
        sharpe_ratio = 0

    return total_return, max_drawdown, sharpe_ratio

if __name__ == '__main__':
    # 1. Load data
    try:
        price_df = pd.read_csv('btc_1m.csv', names=['ts', 'open', 'high', 'low', 'close', 'volume'])
        signals_df = pd.read_csv('signals.csv') # ts, side, entry, sl, tp
    except FileNotFoundError as e:
        print(f"Error: {e}. Make sure 'btc_1m.csv' (no header) and 'signals.csv' are present.")
        exit()

    # Ensure timestamps are numeric for comparison (OS-agnostic method)
    price_df['ts'] = pd.to_datetime(price_df['ts']).view('int64') // 10**9
    signals_df['ts'] = pd.to_datetime(signals_df['ts']).view('int64') // 10**9
    num_days = (price_df['ts'].max() - price_df['ts'].min()) / (60 * 60 * 24)

    # 5. Parameter Grid Search
    bb_windows = [10, 20, 30]
    bb_multipliers = [1.5, 2.0, 2.5]
    results = []

    print("Running backtest grid search...")
    for window, mult in product(bb_windows, bb_multipliers):
        equity_curve, trades = run_backtest(price_df, signals_df, window, mult)
        if len(equity_curve) > 1:
            total_r, max_dd, sharpe = calculate_metrics(equity_curve, num_days)
            results.append(((window, mult), total_r, max_dd, sharpe, len(trades)))
    
    # Print results
    print("\n--- Backtest Results ---")
    print(f"{'Params (win, std)':<20} | {'Total Return':>15} | {'Max Drawdown':>15} | {'Sharpe Ratio':>15} | {'Num Trades':>12}")
    print('-'*85)
    sorted_results = sorted(results, key=lambda x: x[3], reverse=True) # Sort by Sharpe
    for params, total_r, max_dd, sharpe, num_trades in sorted_results:
        print(f"{str(params):<20} | {total_r:>14.2%} | {max_dd:>14.2%} | {sharpe:>15.2f} | {num_trades:>12}")

    # Plot the best result
    if sorted_results:
        best_params = sorted_results[0][0]
        print(f"\nPlotting equity curve for best params: {best_params}")
        best_equity_curve, _ = run_backtest(price_df, signals_df, best_params[0], best_params[1])
        plt.figure(figsize=(12, 6))
        plt.plot(best_equity_curve)
        plt.title(f'Equity Curve - Best Params: {best_params} (Sharpe: {sorted_results[0][3]:.2f})')
        plt.xlabel('Trade Number')
        plt.ylabel('Equity (USDT)')
        plt.grid(True)
        plt.savefig('equity_curve.png')
        print("Saved equity curve to equity_curve.png")

🔹 File: bybit_wrapper.py
----------------------------------------------
import ccxt.async_support as ccxt
import os
from trade_logger import log_trade_execution, log_event

class AsyncBybitWrapper:
    def __init__(self, api_key: str, secret_key: str, testnet: bool = True):
        if not api_key or not secret_key:
            raise ValueError("API key and secret must be provided.")
        
        self.testnet = testnet
        self.exchange = ccxt.bybit({
            'apiKey': api_key,
            'secret': secret_key,
            'options': {'defaultType': 'swap'},
        })
        if self.testnet:
            self.exchange.set_sandbox_mode(True)

    async def init(self):
        try:
            await self.exchange.load_markets()
            print(f"Successfully connected to Bybit. Sandbox mode: {self.testnet}")
        except Exception as e:
            await self.close()
            raise

    async def close(self):
        if self.exchange:
            await self.exchange.close()

    # --- ДОБАВЬТЕ ЭТИ ДВА МЕТОДА ---
    async def set_leverage(self, symbol: str, leverage: int):
        """Устанавливает кредитное плечо для указанного символа."""
        try:
            await self.exchange.set_leverage(leverage, symbol)
            log_event("LEVERAGE_SET", {"symbol": symbol, "leverage": leverage})
        except Exception as e:
            log_event("LEVERAGE_ERROR", {"symbol": symbol, "error": str(e)})
            # Можно не кидать исключение, если биржа позволяет торговать и так
            print(f"Warning: Failed to set leverage for {symbol}: {e}")

    async def set_margin_mode(self, symbol: str, margin_mode: str):
        """Устанавливает режим маржи ('cross' или 'isolated')."""
        try:
            unified_symbol = symbol.split(':')[0]
            await self.exchange.set_margin_mode(margin_mode, unified_symbol, params={'settleCoin': 'USDT'})
            log_event("MARGIN_MODE_SET", {"symbol": symbol, "mode": margin_mode})
        except Exception as e:
            log_event("MARGIN_MODE_ERROR", {"symbol": symbol, "error": str(e)})
            print(f"Warning: Failed to set margin mode for {symbol}: {e}")
    # ------------------------------------

    def get_market_precision(self, symbol: str) -> dict:
        try:
            market = self.exchange.market(symbol)
            return {'price': market['precision']['price'], 'amount': market['precision']['amount']}
        except (ccxt.BadSymbol, KeyError):
            return None

    async def get_usdt_balance(self) -> float:
        try:
            balance = await self.exchange.fetch_balance()
            return float(balance.get('USDT', {}).get('total', 0.0))
        except Exception as e:
            return 0.0

    async def fetch_open_positions(self) -> dict:
        try:
            positions = await self.exchange.fetch_positions()
            return {p['info']['symbol']: p for p in positions if float(p.get('contracts', 0)) != 0}
        except Exception:
            return {}
    
    # --- ДОБАВЬТЕ ЭТОТ МЕТОД ---
    async def fetch_ticker_price(self, symbol: str) -> float:
        """Получает последнюю цену для тикера."""
        try:
            ticker = await self.exchange.fetch_ticker(symbol)
            return float(ticker['last'])
        except Exception as e:
            print(f"Error fetching ticker for {symbol}: {e}")
            return 0.0
    # ---------------------------

    async def create_market_order_with_sl(self, symbol: str, side: str, amount: float, stop_loss_price: float) -> dict:
        params = {'stopLoss': stop_loss_price}
        try:
            order = await self.exchange.create_order(symbol, 'market', side, amount, params=params)
            log_trade_execution(order)
            return order
        except Exception as e:
            error_payload = {'symbol': symbol, 'error': str(e)}
            log_trade_execution(error_payload)
            return error_payload
    
    async def create_order(self, symbol: str, type: str, side: str, amount: float, price: float = None, params={}) -> dict:
        """Универсальный метод для создания ордеров."""
        try:
            order = await self.exchange.create_order(symbol, type, side, amount, price, params)
            log_trade_execution(order)
            return order
        except Exception as e:
            error_payload = {'symbol': symbol, 'type': type, 'side': side, 'error': str(e)}
            log_trade_execution(error_payload)
            raise e
        
    async def create_limit_order(self, symbol: str, side: str, amount: float, price: float, params={}) -> dict:
        """Создает лимитный ордер."""
        try:
            order = await self.exchange.create_limit_order(symbol, side, amount, price, params=params)
            log_trade_execution(order)
            return order
        except Exception as e:
            error_payload = {'symbol': symbol, 'side': side, 'amount': amount, 'price': price, 'error': str(e)}
            log_trade_execution(error_payload)
            raise  # Перебрасываем исключение, чтобы вызывающий код мог его обработать

    async def edit_order(self, order_id: str, symbol: str, new_price: float) -> dict:
        """Редактирует цену существующего ордера (обычно для SL/TP)."""
        try:
            order = await self.exchange.edit_order(order_id, symbol, params={'triggerPrice': new_price})
            log_event("ORDER_EDITED", order)
            return order
        except Exception as e:
            error_payload = {'order_id': order_id, 'symbol': symbol, 'new_price': new_price, 'error': str(e)}
            log_event("ORDER_EDIT_FAILED", error_payload)
            raise
    
    async def cancel_order(self, order_id: str, symbol: str) -> dict:
        """Отменяет ордер."""
        try:
            response = await self.exchange.cancel_order(order_id, symbol)
            log_event("ORDER_CANCELLED", response)
            return response
        except Exception as e:
            error_payload = {'order_id': order_id, 'symbol': symbol, 'error': str(e)}
            log_event("ORDER_CANCEL_FAILED", error_payload)
            # Не перебрасываем исключение, т.к. ордер мог уже быть исполнен/отменен
            return error_payload

    async def fetch_my_trades(self, symbol: str, limit: int = 20) -> list:
        """Получает историю последних сделок пользователя."""
        if self.exchange.has['fetchMyTrades']:
            return await self.exchange.fetch_my_trades(symbol, limit=limit)
        return []

🔹 File: check_keys.py
----------------------------------------------
# File: check_keys.py (ВЕРСИЯ С ХАРДКОДОМ)
import os
import asyncio
import ccxt.async_support as ccxt
# from dotenv import load_dotenv # Больше не нужно

async def main():
    # load_dotenv() # Больше не нужно
    
    # --- ВРЕМЕННО ВСТАВЛЯЕМ КЛЮЧИ ПРЯМО СЮДА ---
    api_key = "Xyo4o0isLLDU1vaRlN"
    secret = "L4BnWcl26eeeWYT3keMiKLtnFwmKm0tKQoJp"
    # ---------------------------------------------

    print(f"--- Checking Keys (Hardcoded) ---")
    print(f"API Key used: {api_key}")
    print("-" * 20)

    exchange = ccxt.bybit({
        'apiKey': api_key,
        'secret': secret,
    })
    exchange.set_sandbox_mode(True)

    try:
        print("Attempting to fetch balance...")
        balance = await exchange.fetch_balance()
        print("\nSUCCESS! Connection is working.")
        print(f"Available USDT Balance: {balance.get('USDT', {}).get('free', 0.0)}")
    except ccxt.AuthenticationError as e:
        print(f"\nERROR: Authentication failed. Bybit says: {e}")
        print("This confirms the issue is with the keys themselves or their permissions on Bybit's side.")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
    finally:
        await exchange.close()

if __name__ == "__main__":
    asyncio.run(main())

🔹 File: dashboard.py
----------------------------------------------
# file: dashboard.py
import streamlit as st
import pandas as pd
from streamlit_autorefresh import st_autorefresh
from db_utils import get_db_connection
import json

# --- Конфигурация ---
REFRESH_INTERVAL_SECONDS = 10
st.set_page_config(page_title="Trading Bot Dashboard", layout="wide")
st_autorefresh(interval=REFRESH_INTERVAL_SECONDS * 1000, key="dashboard_refresh")

# --- Функции для загрузки данных ---
@st.cache_data(ttl=REFRESH_INTERVAL_SECONDS)
def load_data():
    conn = get_db_connection()
    active = pd.read_sql_query("SELECT * FROM managed_trades WHERE status != 'CLOSED' ORDER BY created_at DESC", conn)
    history = pd.read_sql_query("SELECT * FROM managed_trades WHERE status = 'CLOSED' ORDER BY updated_at DESC LIMIT 50", conn)
    # Используем left join для обогащения активных сделок живыми ценами
    prices = pd.read_sql_query("SELECT * FROM live_prices", conn)
    if not active.empty and not prices.empty:
        active = pd.merge(active, prices, on='symbol', how='left')
    conn.close()
    return active, history

# --- Основная структура дашборда ---
st.title("🤖 Stateful Trading Bot Dashboard v2.0")
active_df, history_df = load_data()

# --- Блок 1: Управляемые Сделки ---
st.subheader("📊 Managed Trades")
if not active_df.empty:
    active_df['progress'] = active_df['executed_qty'] / active_df['total_qty']
    # Добавим uPNL (упрощенно)
    if 'mark_price' in active_df.columns:
        active_df['uPNL'] = (active_df['mark_price'] - active_df['avg_entry_price']) * active_df['executed_qty']
        active_df.loc[active_df['side'] == 'short', 'uPNL'] *= -1

    st.dataframe(
        active_df.style.bar(subset=['progress'], align='mid', color=['#d6e8d6', '#e8d6d6']),
        use_container_width=True, hide_index=True
    )
else:
    st.info("No active trades to manage.")

# --- Блок 2: История Сделок ---
st.subheader("📈 Trade History")
if not history_df.empty:
    st.dataframe(history_df, use_container_width=True, hide_index=True)
else:
    st.info("Trade history is empty.")

# --- Блок 3: Журнал Событий (опционально, если нужен) ---
# ...

🔹 File: db_setup.py
----------------------------------------------
# file: db_setup.py
import sqlite3
from db_utils import get_db_connection

def setup_database():
    """
    Creates or updates all necessary tables and indexes in the DB.
    This script is idempotent and safe to run multiple times.
    """
    print("--- Starting Database Setup ---")
    conn = get_db_connection()
    cursor = conn.cursor()

    try:
        # Table 1: Managed Trades (the heart of the system)
        print("1. Creating 'managed_trades' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS managed_trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            instruction_id TEXT NOT NULL,
            symbol TEXT NOT NULL,
            side TEXT NOT NULL CHECK(side IN ('long', 'short')),
            status TEXT NOT NULL CHECK(status IN ('PENDING_ENTRY', 'ACTIVE', 'CLOSING', 'CLOSED')),
            
            entry_range_start REAL NOT NULL,
            entry_range_end REAL NOT NULL,
            initial_tps TEXT NOT NULL,
            
            avg_entry_price REAL,
            total_qty REAL NOT NULL,
            executed_qty REAL NOT NULL DEFAULT 0,
            
            initial_sl_price REAL NOT NULL,
            current_sl_price REAL NOT NULL,
            exchange_sl_order_id TEXT,
            
            -- CORRECTED COLUMN DEFINITION --
            move_sl_to_be_after_tp_index INTEGER, 
            
            remaining_tps TEXT NOT NULL,
            close_reason TEXT,
            realized_pnl REAL,
            
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL
        );
        """)
        print("   ... 'managed_trades' table is ready.")

        # Table 2: Entry Orders
        print("2. Creating 'entry_orders' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS entry_orders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            trade_id INTEGER NOT NULL,
            exchange_order_id TEXT NOT NULL UNIQUE,
            status TEXT NOT NULL,
            FOREIGN KEY (trade_id) REFERENCES managed_trades (id)
        );
        """)
        print("   ... 'entry_orders' table is ready.")

        # Table 3: Live Prices
        print("3. Creating 'live_prices' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS live_prices (
            symbol TEXT PRIMARY KEY,
            mark_price REAL NOT NULL,
            updated_at TEXT NOT NULL
        );
        """)
        print("   ... 'live_prices' table is ready.")

        # Table 4: Daily PnL for Risk Controls
        print("4. Creating 'daily_pnl' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS daily_pnl (
            trade_date DATE PRIMARY KEY,
            realised_pnl REAL NOT NULL DEFAULT 0
        );
        """)
        print("   ... 'daily_pnl' table is ready.")
        
        # Table 5: General Event Log
        print("5. Creating 'trade_log' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS trade_log (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           timestamp_utc TEXT NOT NULL,
           event_type TEXT NOT NULL,
           -- CORRECTED COLUMN DEFINITION (NULLABLE) --
           payload_json TEXT 
        );
        """)
        print("   ... 'trade_log' table is ready.")

        # Indexes for performance
        print("6. Creating indexes for performance...")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_managed_trades_status ON managed_trades(status);")
        # ... other indexes ...
        print("   ... Indexes are ready.")
        
        # Schema versioning
        print("7. Setting up schema version...")
        cursor.execute("CREATE TABLE IF NOT EXISTS db_meta (key TEXT PRIMARY KEY, value TEXT NOT NULL);")
        cursor.execute("INSERT OR IGNORE INTO db_meta (key, value) VALUES ('schema_version', '3');")
        print("   ... Schema version is set.")

        conn.commit()
        print("\n--- Database setup successfully completed! ---")

    except Exception as e:
        print(f"\n--- An error occurred during database setup: {e} ---")
        conn.rollback()
    finally:
        conn.close()

if __name__ == "__main__":
    setup_database()

🔹 File: db_utils.py
----------------------------------------------
# file: db_utils.py
import sqlite3
import json
from datetime import datetime, timezone
import os

# Путь к БД теперь берется из env-переменной для гибкости и тестирования
# Фикстура в conftest.py будет подменять эту переменную во время тестов.
DATABASE_FILE = os.getenv("DATABASE_FILE", "trades.sqlite")

def get_db_connection() -> sqlite3.Connection:
    """
    Возвращает НОВОЕ соединение с SQLite с настройками для production.
    """
    # timeout=30 (в секундах) автоматически установит busy_timeout
    # check_same_thread=False важно для FastAPI, но требует аккуратного управления транзакциями.
    conn = sqlite3.connect(DATABASE_FILE, timeout=30, check_same_thread=False)
    # WAL-режим для безопасной конкурентной работы
    conn.execute("PRAGMA journal_mode=WAL;")
    conn.row_factory = sqlite3.Row
    return conn

def create_managed_trade(instruction: dict, total_qty: float) -> int:
    """
    Создает запись о новой сделке в таблице managed_trades.
    Эта функция сама управляет своим соединением с БД, чтобы быть потоко-безопасной.
    """
    conn = get_db_connection()
    try:
        now_utc = datetime.now(timezone.utc).isoformat(timespec='microseconds')
        
        # Используем `with conn:` для автоматического коммита или отката транзакции
        with conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO managed_trades (
                    instruction_id, symbol, side, status, entry_range_start, entry_range_end,
                    total_qty, initial_sl_price, current_sl_price, initial_tps, remaining_tps,
                    move_sl_to_be_after_tp_index, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    instruction.get('signal_id', 'unknown'), 
                    instruction.get('symbol', 'BTCUSDT'), 
                    instruction['side'], 
                    'PENDING_ENTRY',
                    instruction['entry_start'], 
                    instruction['entry_end'], 
                    total_qty,
                    instruction['stop_loss'], 
                    instruction['stop_loss'],
                    json.dumps(instruction['take_profits']), 
                    json.dumps(instruction['take_profits']),
                    instruction.get('move_sl_to_be_after_tp_index', 1),
                    now_utc, 
                    now_utc
                )
            )
            trade_id = cursor.lastrowid
    finally:
        # Гарантированно закрываем соединение
        if conn:
            conn.close()
            
    return trade_id

🔹 File: main.py
----------------------------------------------
# file: main.py
import asyncio
import os
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, Depends
from dotenv import load_dotenv
import sqlite3

load_dotenv()

from bybit_wrapper import AsyncBybitWrapper
from risk_sizer import calculate_position_size
from risk_controls import check_daily_drawdown
from trade_logger import log_event
from signal_parser import parse_pentagon_signal
from db_utils import get_db_connection, create_managed_trade 
from position_manager import position_manager_loop, place_entry_grid
from models import TradeInstruction

API_KEY = os.getenv("BYBIT_KEY")
API_SECRET = os.getenv("BYBIT_SECRET")
if not API_KEY or not API_SECRET:
    raise RuntimeError("BYBIT_KEY and BYBIT_SECRET must be set in .env file")

bybit_client = AsyncBybitWrapper(api_key=API_KEY, secret_key=API_SECRET, testnet=True)
background_tasks = set()

@asynccontextmanager
async def lifespan(app: FastAPI):
    await bybit_client.init()
    manager_task = asyncio.create_task(position_manager_loop(bybit_client))
    background_tasks.add(manager_task)
    manager_task.add_done_callback(background_tasks.discard)
    log_event("APP_STARTUP", {"message": "Position manager started."})
    
    yield
    
    log_event("APP_SHUTDOWN", {"message": "Cancelling background tasks."})
    for task in list(background_tasks): # Iterate over a copy
        task.cancel()
    await bybit_client.close()
    log_event("APP_SHUTDOWN_COMPLETE", {"message": "Bybit client closed."})

app = FastAPI(title="Stateful Trading Bot", version="1.0.0", lifespan=lifespan)

def get_db():
    db = get_db_connection()
    try:
        yield db
    finally:
        db.close()

@app.post("/process_signal", status_code=202)
@check_daily_drawdown(max_loss_pct=0.03) 
async def process_signal(raw_text: str, db: sqlite3.Connection = Depends(get_db)): 
    instruction = parse_pentagon_signal(raw_text)
    if not instruction:
        raise HTTPException(status_code=400, detail="Signal parsing failed.")
    
    log_event("INSTRUCTION_PARSED", instruction.model_dump())

    equity = await bybit_client.get_usdt_balance()
    precision = bybit_client.get_market_precision(instruction.symbol)
    if not precision or 'amount' not in precision:
        raise HTTPException(status_code=500, detail="Could not get precision for symbol {instruction.symbol}")

    risk_entry_price = instruction.entry_end if instruction.side == 'short' else instruction.entry_start
    total_qty = calculate_position_size(
        entry_price=risk_entry_price, stop_loss_price=instruction.stop_loss,
        equity=equity, amount_precision_step=precision['amount'],
        risk_pct=instruction.risk_pct
    )
    final_qty = total_qty * instruction.size_fraction
    if final_qty <= 0:
        raise HTTPException(status_code=400, detail="Calculated position size is zero.")

    trade_id = create_managed_trade(instruction.model_dump(), final_qty) 
    log_event("TRADE_CREATED_IN_DB", {"trade_id": trade_id, "qty": final_qty})

    task = asyncio.create_task(
        place_entry_grid(trade_id, final_qty, instruction.model_dump(), bybit_client)
    )
    background_tasks.add(task)
    task.add_done_callback(background_tasks.discard)

    return {"status": "accepted", "trade_id": trade_id}

🔹 File: models.py
----------------------------------------------
# file: models.py
from pydantic import BaseModel, Field
from typing import List, Optional

class TradeInstruction(BaseModel):
    """Структурированная инструкция, полученная из парсера."""
    signal_id: str
    symbol: str = "BTCUSDT"
    side: str
    entry_start: float
    entry_end: float
    stop_loss: float
    risk_pct: float = Field(..., gt=0, le=0.1)
    size_fraction: float = Field(default=1.0, ge=0.1, le=1.0)
    take_profits: List[float]
    move_sl_to_be_after_tp_index: int = 1

🔹 File: position_manager.py
----------------------------------------------
# file: position_manager.py
import asyncio
import json
import numpy as np
import sqlite3
from datetime import datetime, timezone

from db_utils import get_db_connection
from trade_logger import log_event
from bybit_wrapper import AsyncBybitWrapper
from risk_controls import update_pnl

# --- Константы ---
MANAGER_LOOP_SLEEP_INTERVAL = 15
ENTRY_GRID_ORDERS = 3

# ==============================================================================
# 1. ЗАДАЧА РАЗМЕЩЕНИЯ ОРДЕРОВ (уже была правильной)
# ==============================================================================
async def place_entry_grid(trade_id: int, total_qty: float, instruction: dict, bybit_client: AsyncBybitWrapper):
    """
    Выставляет сетку лимитных ордеров на вход для новой сделки.
    Эта функция корректно управляет своим собственным соединением с БД.
    """
    conn = get_db_connection()
    try:
        existing_orders = conn.execute("SELECT 1 FROM entry_orders WHERE trade_id = ?", (trade_id,)).fetchone()
        if existing_orders:
            log_event("GRID_PLACEMENT_SKIPPED", {"reason": "already_exists", "trade_id": trade_id})
            return

        precision = bybit_client.get_market_precision(instruction['symbol'])
        if not precision or not precision.get('amount'):
            log_event("GRID_PLACEMENT_ERROR", {"reason": "missing_precision", "trade_id": trade_id})
            return

        amount_step = precision.get('amount', 1e-8) # Безопасное значение по умолчанию
        order_qty = round(total_qty / ENTRY_GRID_ORDERS, int(-np.log10(amount_step)))
        if order_qty <= 0:
            log_event("GRID_PLACEMENT_ERROR", {"reason": "zero_order_qty", "trade_id": trade_id})
            return
            
        entry_prices = np.linspace(instruction['entry_start'], instruction['entry_end'], ENTRY_GRID_ORDERS)
        
        with conn:
            for price in entry_prices:
                try:
                    order = await bybit_client.create_limit_order(
                        symbol=instruction['symbol'], side=instruction['side'], amount=order_qty, price=price
                    )
                    log_event("ENTRY_ORDER_PLACED", {"trade_id": trade_id, "order_id": order['id'], "price": price})
                    conn.execute(
                        "INSERT INTO entry_orders (trade_id, exchange_order_id, status) VALUES (?, ?, ?)",
                        (trade_id, order['id'], 'open')
                    )
                except Exception as e:
                    log_event("ENTRY_ORDER_FAILED", {"trade_id": trade_id, "price": price, "error": str(e)})
    finally:
        if conn:
            conn.close()

# ==============================================================================
# 2. ГЛАВНЫЙ ЦИКЛ МЕНЕДЖЕРА (ИСПРАВЛЕНО)
# ==============================================================================
async def position_manager_loop(bybit_client: AsyncBybitWrapper):
    """Главный цикл, который управляет всеми активными и ожидающими сделками."""
    log_event("POSITION_MANAGER_STARTED", {})
    while True:
        try:
            trades_to_manage = []
            conn = get_db_connection()
            try:
                # Получаем список сделок и сразу закрываем соединение
                trades_to_manage_rows = conn.execute("SELECT * FROM managed_trades WHERE status != 'CLOSED'").fetchall()
                trades_to_manage = [dict(row) for row in trades_to_manage_rows]
            finally:
                conn.close()
            
            if not trades_to_manage:
                await asyncio.sleep(MANAGER_LOOP_SLEEP_INTERVAL)
                continue

            live_positions = await bybit_client.fetch_open_positions()
            
            active_symbols = {trade['symbol'] for trade in trades_to_manage}
            if active_symbols:
                # Эта функция сама управляет своим соединением
                await update_live_prices(bybit_client, list(active_symbols))
            
            for trade in trades_to_manage:
                # Передаем bybit_client, но не соединение
                await reconcile_and_manage(trade, live_positions.get(trade['symbol']), bybit_client)
                
        except asyncio.CancelledError:
            log_event("POSITION_MANAGER_STOPPED", {})
            break
        except Exception as e:
            log_event("POSITION_MANAGER_ERROR", {"error": str(e), "context": "Main Loop"})
        
        await asyncio.sleep(MANAGER_LOOP_SLEEP_INTERVAL)

# ==============================================================================
# 3. ЛОГИКА СВЕРКИ И УПРАВЛЕНИЯ (ИСПРАВЛЕНО)
# ==============================================================================
async def reconcile_and_manage(trade: dict, live_position: dict, bybit_client: AsyncBybitWrapper):
    """
    Центральная стейт-машина для одной сделки.
    Больше не принимает 'conn', а создает соединения по необходимости.
    """
    trade_id = trade['id']
    status = trade['status']
    now_utc = datetime.now(timezone.utc).isoformat(timespec='microseconds')

    try:
        # --- Состояние: PENDING_ENTRY -> ACTIVE ---
        if status == 'PENDING_ENTRY' and live_position:
            avg_price = float(live_position['entryPrice'])
            exec_qty = float(live_position['contracts'])
            log_event("ENTRY_DETECTED", {"trade_id": trade_id, "avg_price": avg_price, "qty": exec_qty})
            
            sl_order = await bybit_client.create_order(
                symbol=trade['symbol'], type='market', side='buy' if trade['side'] == 'short' else 'sell',
                amount=exec_qty, params={'stopLoss': trade['initial_sl_price'], 'reduceOnly': True}
            )
            sl_order_id = sl_order.get('id')
            
            conn = get_db_connection()
            try:
                entry_orders_to_cancel = conn.execute("SELECT exchange_order_id FROM entry_orders WHERE trade_id = ? AND status = 'open'", (trade_id,)).fetchall()
            finally:
                conn.close()

            for order_row in entry_orders_to_cancel:
                await bybit_client.cancel_order(order_row['exchange_order_id'], trade['symbol'])

            conn = get_db_connection()
            try:
                with conn:
                    conn.execute(
                        "UPDATE managed_trades SET status=?, avg_entry_price=?, executed_qty=?, exchange_sl_order_id=?, updated_at=? WHERE id=?",
                        ('ACTIVE', avg_price, exec_qty, sl_order_id, now_utc, trade_id)
                    )
                    conn.execute("UPDATE entry_orders SET status='cancelled' WHERE trade_id=? AND status='open'", (trade_id,))
                log_event("TRADE_ACTIVATED", {"trade_id": trade_id, "sl_order_id": sl_order_id})
            finally:
                conn.close()

        # --- Состояние: ACTIVE -> CLOSED ---
        elif status == 'ACTIVE' and not live_position:
            # ... (код выше без изменений) ...
            pnl, reason = await get_realized_pnl(trade, bybit_client)

            conn = get_db_connection()
            try:
                with conn:
                    # ИСПРАВЛЕНИЕ: Добавляем недостающий UPDATE-запрос
                    conn.execute(
                        "UPDATE managed_trades SET status='CLOSED', close_reason=?, realized_pnl=?, updated_at=? WHERE id=?",
                        (reason, pnl, now_utc, trade_id)
                    )
                # Убедимся, что PnL не None перед обновлением
                if pnl is not None:
                    update_pnl(conn, pnl) 
            finally:
                conn.close()
            log_event("PNL_UPDATED", {"trade_id": trade_id, "pnl": pnl})

        # --- Состояние: ACTIVE (Управление TP / SL) ---
        elif status == 'ACTIVE' and live_position:
            remaining_tps = json.loads(trade['remaining_tps'])
            if not remaining_tps: return

            mark_price = float(live_position['markPrice'])
            next_tp_price = remaining_tps[0]

            tp_hit = (trade['side'] == 'long' and mark_price >= next_tp_price) or \
                     (trade['side'] == 'short' and mark_price <= next_tp_price)

            if tp_hit:
                initial_tps_count = len(json.loads(trade['initial_tps']))
                precision = bybit_client.get_market_precision(trade['symbol'])
                amount_step = precision.get('amount', 1e-8)
                tp_qty = round(trade['total_qty'] / initial_tps_count, int(-np.log10(amount_step)))
                
                if tp_qty > 0:
                    await bybit_client.create_limit_order(
                        symbol=trade['symbol'], side='buy' if trade['side'] == 'short' else 'sell',
                        amount=tp_qty, price=next_tp_price, params={'reduceOnly': True}
                    )
                
                remaining_tps.pop(0)
                conn = get_db_connection()
                try:
                    with conn:
                        conn.execute("UPDATE managed_trades SET remaining_tps=?, updated_at=? WHERE id=?", (json.dumps(remaining_tps), now_utc, trade_id))
                    log_event("TP_ORDER_PLACED", {"trade_id": trade_id, "tp_price": next_tp_price})
                finally:
                    conn.close()
            
            initial_tps_count = len(json.loads(trade['initial_tps']))
            tps_taken = initial_tps_count - len(remaining_tps)
            
            if (trade.get('move_sl_to_be_after_tp_index') is not None and 
                tps_taken >= trade['move_sl_to_be_after_tp_index'] and 
                trade['avg_entry_price'] is not None and
                trade['current_sl_price'] != trade['avg_entry_price']):
                
                new_sl_price = trade['avg_entry_price']
                log_event("MOVING_SL_TO_BREAKEVEN", {"trade_id": trade_id, "new_sl": new_sl_price})
                
                await bybit_client.edit_order(
                    trade['exchange_sl_order_id'], trade['symbol'], new_sl_price
                )
                conn = get_db_connection()
                try:
                    with conn:
                        conn.execute("UPDATE managed_trades SET current_sl_price=?, updated_at=? WHERE id=?", (new_sl_price, now_utc, trade_id))
                    log_event("SL_MOVE_SUCCESS", {"trade_id": trade_id})
                finally:
                    conn.close()

    except Exception as e:
        log_event("RECONCILE_ERROR", {"trade_id": trade_id, "error": str(e), "status": status})

# ==============================================================================
# 4. ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ (ИСПРАВЛЕНО)
# ==============================================================================
async def update_live_prices(bybit_client: AsyncBybitWrapper, symbols: list):
    """Запрашивает и обновляет живые цены, управляя своим соединением."""
    conn = get_db_connection()
    try:
        tickers = await asyncio.gather(*[bybit_client.fetch_ticker_price(s) for s in symbols])
        now_utc = datetime.now(timezone.utc).isoformat(timespec='microseconds')
        
        with conn:
            for symbol, price in zip(symbols, tickers):
                if price > 0:
                    conn.execute(
                        "INSERT OR REPLACE INTO live_prices (symbol, mark_price, updated_at) VALUES (?, ?, ?)",
                        (symbol, price, now_utc)
                    )
    except Exception as e:
        log_event("LIVE_PRICE_UPDATE_ERROR", {"error": str(e)})
    finally:
        if conn:
            conn.close()

async def get_realized_pnl(trade: dict, bybit_client: AsyncBybitWrapper) -> tuple[float, str]:
    """
    Получает историю сделок пользователя с биржи для расчета PnL.
    Эта функция не взаимодействует с локальной БД.
    """
    try:
        my_trades = await bybit_client.fetch_my_trades(trade['symbol'], limit=20)
        
        trade_open_time = datetime.fromisoformat(trade['created_at'])
        relevant_trades = [t for t in my_trades if t.get('timestamp') and datetime.fromtimestamp(t['timestamp'] / 1000, tz=timezone.utc) > trade_open_time]
        
        if not relevant_trades:
            return 0.0, "UNKNOWN_NO_TRADES"

        realized_pnl = sum(t.get('fee', {}).get('cost', 0) * -1 for t in relevant_trades if t.get('fee'))

        last_trade = relevant_trades[-1]
        if last_trade.get('price') and trade.get('current_sl_price') and last_trade['price'] == trade['current_sl_price']:
            return realized_pnl, "SL_HIT"
        elif last_trade.get('price') and trade.get('initial_tps') and last_trade['price'] in json.loads(trade['initial_tps']):
             return realized_pnl, "TP_HIT"
        else:
            return realized_pnl, "MANUAL_OR_OTHER"

    except Exception as e:
        log_event("PNL_FETCH_ERROR", {"trade_id": trade['id'], "error": str(e)})
        return 0.0, "ERROR_FETCHING_PNL"

🔹 File: risk_controls.py
----------------------------------------------
# file: risk_controls.py
import sqlite3
import os
from datetime import date, datetime 
from functools import wraps
from fastapi import HTTPException

# --- CHANGE 1: Import the central DB connection utility ---
from db_utils import get_db_connection

# --- CHANGE 2: Remove the local get_db_connection() and initialize_pnl_table() functions ---
# They are no longer needed here.

INITIAL_EQUITY = 1000.0

def check_daily_drawdown(max_loss_pct: float = 0.03):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            today = date.today()
            # This call now correctly uses the function from db_utils,
            # which is properly patched by your tests.
            conn = get_db_connection()
            cursor = conn.cursor()
            
            current_equity = INITIAL_EQUITY
            max_loss_usd = current_equity * max_loss_pct

            try:
                cursor.execute("SELECT realised_pnl FROM daily_pnl WHERE trade_date = ?", (today,))
                result = cursor.fetchone()
                realised_pnl = result['realised_pnl'] if result else 0.0
            except sqlite3.OperationalError as e:
                # Handle case where table might not exist in a faulty setup, but log it.
                print(f"Database error in check_daily_drawdown: {e}")
                realised_pnl = 0.0
            finally:
                conn.close()

            if realised_pnl <= -max_loss_usd:
                raise HTTPException(
                    status_code=429,
                    detail=f"Daily loss limit of ${max_loss_usd:.2f} reached. Realised PnL: ${realised_pnl:.2f}. No new trades allowed."
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# --- CHANGE 3: Modify update_pnl to accept a connection object ---
def update_pnl(conn: sqlite3.Connection, pnl: float):
    """Updates the PnL for the current day using the provided connection."""
    
    # --- НАША ОТЛАДОЧНАЯ ЛОВУШКА ---
    now = datetime.now().strftime("%H:%M:%S.%f")
    print(f"\nDEBUG_TRAP [{now}]: update_pnl CALLED! PNL = {pnl}\n")
    # ---------------------------------
    
    today = date.today()
    try:
        with conn:
            conn.execute('''
                INSERT INTO daily_pnl (trade_date, realised_pnl)
                VALUES (?, ?)
                ON CONFLICT(trade_date) DO UPDATE SET
                realised_pnl = realised_pnl + excluded.realised_pnl;
            ''', (today, pnl))
    except Exception as e:
        print(f"ERROR in update_pnl: {e}")

🔹 File: risk_sizer.py
----------------------------------------------
# File: risk_sizer.py
import math

RISK_PER_TRADE_PCT = 0.01

def calculate_position_size(
    entry_price: float,
    stop_loss_price: float,
    equity: float,
    amount_precision_step: float,
    risk_pct: float = RISK_PER_TRADE_PCT
) -> float:
    
    price_diff = abs(entry_price - stop_loss_price)
    if equity <= 0 or price_diff == 0:
        return 0.0
        
    risk_per_trade_usd = equity * risk_pct
    position_size = risk_per_trade_usd / price_diff

    # ИЗМЕНЕНО: Используем более надежный метод округления
    if amount_precision_step == 1:
        # Для целых чисел (как SHIB) используем стандартное округление до целого
        return round(position_size)
    else:
        # Для дробных - вычисляем количество знаков из шага
        decimal_places = -int(math.log10(amount_precision_step))
        return round(position_size, decimal_places)

🔹 File: signal_parser.py
----------------------------------------------
# file: signal_parser.py
import re
import hashlib
from typing import Optional
from models import TradeInstruction

def parse_pentagon_signal(text: str) -> Optional[TradeInstruction]:
    """Парсит текстовый сигнал и возвращает структурированный объект TradeInstruction."""
    try:
        side_match = re.search(r'(лонг|шорт)', text, re.IGNORECASE)
        side = 'long' if 'лонг' in side_match.group(0).lower() else 'short'

        entry_match = re.search(r'(\d{4,6})-(\d{4,6})', text)
        entry_start, entry_end = sorted([float(entry_match.group(1)), float(entry_match.group(2))])

        sl_match = re.search(r'стоп\s*(?:под|над)?\s*(\d+\.?\d*)', text, re.IGNORECASE)
        stop_loss = float(sl_match.group(1))

        risk_match = re.search(r'риском\s+([\d.]+)\s*%\s*\((\d\/\d)\)', text, re.IGNORECASE)
        risk_pct = float(risk_match.group(1)) / 100
        num, den = map(int, risk_match.group(2).split('/'))
        size_fraction = num / den

        targets_block_match = re.search(r'Цели:([\s\S]*?)(?:\n\n|\Z)', text, re.IGNORECASE)
        targets_block = targets_block_match.group(1)
        take_profits = [float(tp) for tp in re.findall(r'(\d{4,6})', targets_block)]
        if not take_profits:
            raise ValueError("No take profits found in signal")

        signal_id = hashlib.md5(text.encode()).hexdigest()

        return TradeInstruction(
            signal_id=signal_id,
            side=side,
            entry_start=entry_start,
            entry_end=entry_end,
            stop_loss=stop_loss,
            risk_pct=risk_pct,
            size_fraction=size_fraction,
            take_profits=take_profits,
        )
    except (AttributeError, ValueError, IndexError) as e:
        print(f"Signal parsing failed: {e}")
        return None

🔹 File: spring_model.py
----------------------------------------------
import pandas as pd
import numpy as np

def bounce_prob(
    bars: pd.DataFrame,
    side: str,
    price: float,
    bb_window: int = 20,
    bb_std_dev: float = 2.0
) -> float:
    """
    Calculates the 'bounce probability' based on a Bollinger Band mean-reversion model.

    Args:
        bars: DataFrame with historical data, must contain a 'close' column.
        side: The trade side, either 'long' or 'short'.
        price: The current price to evaluate.
        bb_window: The moving average window for Bollinger Bands.
        bb_std_dev: The standard deviation multiplier for Bollinger Bands.

    Returns:
        A probability score [0, 1] indicating the likelihood of a bounce.
    """
    if side not in ['long', 'short']:
        raise ValueError("Side must be either 'long' or 'short'.")

    if len(bars) < bb_window:
        # Not enough data to calculate BBs, no basis for a bounce.
        return 0.0

    # Calculate Bollinger Bands from the historical bars
    closes = bars['close']
    mu = closes.rolling(window=bb_window).mean().iloc[-1]
    sigma = closes.rolling(window=bb_window).std().iloc[-1]

    # Handle case of zero volatility to prevent division by zero
    if sigma == 0:
        return 0.0

    lower_bb = mu - bb_std_dev * sigma
    upper_bb = mu + bb_std_dev * sigma
    p_raw = 0.0

    if side == "long":
        # Probability increases as price drops further below the lower band.
        if price < lower_bb:
            p_raw = (lower_bb - price) / (bb_std_dev * sigma)
    else:  # side == "short"
        # Probability increases as price rises further above the upper band.
        if price > upper_bb:
            p_raw = (price - upper_bb) / (bb_std_dev * sigma)
    
    # Clip the result to be within the valid probability range [0, 1]
    return float(np.clip(p_raw, 0, 1))

🔹 File: tests/__init__.py
----------------------------------------------
# This file is intentionally left empty.
# It marks the 'tests' directory as a Python package.

🔹 File: tests/conftest.py
----------------------------------------------
# file: tests/conftest.py
import pytest
import os
import sqlite3
from unittest.mock import AsyncMock, MagicMock  # <-- Import MagicMock
from fastapi.testclient import TestClient
from datetime import datetime, timezone        # <-- ADD THIS LINE

TEST_DB_FILE = "test_app_db.sqlite"

@pytest.fixture(scope="function", autouse=True)
def setup_for_every_test(monkeypatch, mocker):
    # 1. Isolate the database by deleting files
    monkeypatch.setenv("DATABASE_FILE", TEST_DB_FILE)
    if os.path.exists(TEST_DB_FILE): os.remove(TEST_DB_FILE)
    if os.path.exists(f"{TEST_DB_FILE}-shm"): os.remove(f"{TEST_DB_FILE}-shm")
    if os.path.exists(f"{TEST_DB_FILE}-wal"): os.remove(f"{TEST_DB_FILE}-wal")
    
    # 2. Setup schema in the new, clean file
    from db_setup import setup_database
    setup_database()

    # 3. Mock external services
    mock_main_bybit_client = AsyncMock(name="main_bybit_client_mock")
    mock_main_bybit_client.set_sandbox_mode = MagicMock()
    mock_main_bybit_client.init.return_value = None
    mock_main_bybit_client.get_usdt_balance.return_value = 1000.0
    mock_main_bybit_client.get_market_precision.return_value = {'amount': 0.001, 'price': 0.01}
    mock_main_bybit_client.fetch_open_positions.return_value = {}
    mock_main_bybit_client.fetch_my_trades.return_value = []
    mocker.patch('main.bybit_client', new=mock_main_bybit_client)

    mocker.patch('main.position_manager_loop', new_callable=AsyncMock)
    mocker.patch('main.place_entry_grid', new_callable=AsyncMock)
    
    yield

@pytest.fixture
def test_app_client():
    """Provides a TestClient to the app. The app is now safe to use
    because the autouse fixture has already cleaned and mocked everything."""
    from main import app
    with TestClient(app) as client:
        yield client

# This fixture is for non-API tests that need a standalone mock client.
# It's different from the one used by the app, ensuring no cross-contamination.
@pytest.fixture
def mock_bybit_client():
    """
    Provides a standalone mock client for non-API unit tests.
    """
    client = AsyncMock(name="standalone_mock_bybit_client")
    client.get_market_precision.return_value = {'amount': 0.001, 'price': 0.01}
    client.create_order.return_value = {"id": "stop_loss_order_1"}
    
    # --- ИСПРАВЛЕНИЕ ДЛЯ PNL ---
    # Симулируем, что fetch_my_trades возвращает одну сделку с нулевой комиссией.
    # Это позволит get_realized_pnl вернуть 0.0, а не ошибку.
    client.fetch_my_trades.return_value = [
        {'timestamp': datetime.now(timezone.utc).timestamp() * 1000, 'fee': {'cost': 0.0}}
    ]
    # ---------------------------

    return client

🔹 File: tests/test_api_process_signal.py
----------------------------------------------
# file: tests/test_api_process_signal.py
import pytest
from unittest.mock import AsyncMock
from db_utils import get_db_connection


VALID_SIGNAL_TEXT = "🔴пробую шорт 109200-110500 и риском 0.5% (1/2) стоп над 111500\nЦели: 109000"

def test_api_db_is_clean_before_run(test_app_client):
    """
    Verifies that the database is clean at the start of an API test.
    The app factory pattern ensures no state leaks from previous tests.
    """
    conn = get_db_connection()
    try:
        pnl_record = conn.execute("SELECT * FROM daily_pnl").fetchone()
    finally:
        conn.close()
    
    assert pnl_record is None, "The daily_pnl table should be empty."

def test_process_signal_creates_trade_in_db(test_app_client, mock_place_entry_grid):
    """
    Tests the full API endpoint flow from signal to DB record.
    """
    response = test_app_client.post("/process_signal", params={"raw_text": VALID_SIGNAL_TEXT})

    assert response.status_code == 202, f"API returned an unexpected status. Body: {response.text}"
    data = response.json()
    assert data['status'] == 'accepted'
    trade_id = data['trade_id']

    conn = get_db_connection()
    try:
        trade_in_db = conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone()
    finally:
        conn.close()
    
    assert trade_in_db is not None
    assert trade_in_db['status'] == 'PENDING_ENTRY'
    assert trade_in_db['side'] == 'short'

    mock_place_entry_grid.assert_called_once()
    args, _ = mock_place_entry_grid.call_args
    assert args[0] == trade_id

🔹 File: tests/test_backtest_runner.py
----------------------------------------------
import pytest
import pandas as pd
import numpy as np
from backtest_runner import run_backtest, calculate_metrics

def test_backtest_run(monkeypatch): # <-- ADDED monkeypatch
    # Create synthetic data with some volatility to prevent sigma=0
    prices = pd.DataFrame({
        'ts': range(100, 200),
        'close': list(np.linspace(101, 100, 50)) + list(np.linspace(91, 90, 50)),
        'low': list(np.linspace(100, 99, 50)) + list(np.linspace(86, 85, 50)),
        'high': list(np.linspace(102, 101, 50)) + list(np.linspace(96, 95, 50))
    })
    signals = pd.DataFrame({
        'ts': [150],
        'side': ['long'],
        'entry': [90],
        'sl': [88]
    })
    
    # Use monkeypatch to correctly override the function in the target module
    monkeypatch.setattr("backtest_runner.bounce_prob", lambda *args, **kwargs: 1.0)
    
    equity_curve, trades = run_backtest(prices, signals, bb_window=20, bb_std_dev=2.0)
    
    assert len(trades) > 0
    assert equity_curve[-1] != 1000.0

def test_metrics_calculation():
    equity_curve = [1000, 1010, 1005, 1020, 1015]
    total_r, max_dd, sharpe = calculate_metrics(equity_curve, num_days=1)
    
    assert total_r == pytest.approx(0.015)
    # The calculated value is -0.004950495...
    assert max_dd == pytest.approx(-0.00495, abs=1e-5)
    assert sharpe is not None

🔹 File: tests/test_bybit_wrapper.py
----------------------------------------------
import pytest
from unittest.mock import AsyncMock, MagicMock
import ccxt.async_support as ccxt
from bybit_wrapper import AsyncBybitWrapper

@pytest.fixture
def mock_exchange():
    """Фикстура, создающая мок-объект для ccxt.exchange."""
    exchange = AsyncMock()
    exchange.load_markets.return_value = None
    exchange.set_sandbox_mode = MagicMock(return_value=None) # <-- MODIFY THIS LINE
    exchange.fetch_balance.return_value = {
        'USDT': {'free': 1000.0, 'used': 0.0, 'total': 1000.0}
    }
    exchange.create_order.return_value = {'id': '12345', 'status': 'open'}
    exchange.market.return_value = {
        'precision': {'amount': 3, 'price': 2}
    }
    return exchange


@pytest.mark.asyncio
async def test_init_and_get_balance(mock_exchange, mocker):
    """Тестирует успешную инициализацию и получение баланса."""
    # Подменяем реальный ccxt.bybit на наш мок
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    
    # Создаем экземпляр с фиктивными ключами
    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    balance = await wrapper.get_usdt_balance()
    await wrapper.close()

    assert balance == 1000.0
    mock_exchange.load_markets.assert_called_once()
    mock_exchange.fetch_balance.assert_called_once()


@pytest.mark.asyncio
async def test_create_order_success(mock_exchange, mocker):
    """Тестирует успешное создание ордера."""
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    mock_log = mocker.patch('bybit_wrapper.log_trade_execution')
    
    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    result = await wrapper.create_market_order_with_sl('BTC/USDT:USDT', 'buy', 0.01, 59000.0)
    await wrapper.close()

    assert result['id'] == '12345'
    mock_log.assert_called_once()


@pytest.mark.asyncio
async def test_create_order_insufficient_funds(mock_exchange, mocker):
    """Тестирует обработку ошибки нехватки средств."""
    error_message = "bybit-insufficient-balance-for-order-cost"
    mock_exchange.create_order.side_effect = ccxt.InsufficientFunds(error_message)
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    mock_log = mocker.patch('bybit_wrapper.log_trade_execution')

    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    result = await wrapper.create_market_order_with_sl('BTC/USDT:USDT', 'buy', 1.0, 59000.0)
    await wrapper.close()

    assert 'error' in result
    assert error_message in result['error']
    mock_log.assert_called_once()

🔹 File: tests/test_position_manager.py
----------------------------------------------
# file: tests/test_position_manager.py
import pytest
import json
from datetime import datetime, timezone
from unittest.mock import AsyncMock

# Импортируем тестируемую функцию
from position_manager import reconcile_and_manage
# Импортируем утилиту для получения соединения
from db_utils import get_db_connection

# --- Вспомогательная функция для создания тестовых сделок в БД ---

def create_test_trade_in_db(status='PENDING_ENTRY', avg_price=None, sl_price=85.0, sl_order_id=None, remaining_tps='[110, 120]', move_sl_idx=1, total_qty=1.0):
    """
    Создает запись о сделке в БД и возвращает ее ID.
    Эта функция сама управляет своим соединением с БД.
    """
    conn = get_db_connection()
    try:
        now_utc_iso = datetime.now(timezone.utc).isoformat()
        cursor = conn.cursor()
        # Добавляем все необходимые поля, чтобы избежать ошибок
        initial_tps_json = json.dumps([110, 120])
        remaining_tps_json = remaining_tps if isinstance(remaining_tps, str) else json.dumps(remaining_tps)
        
        cursor.execute("""
            INSERT INTO managed_trades (
                instruction_id, symbol, side, status, entry_range_start, entry_range_end,
                total_qty, avg_entry_price, initial_sl_price, current_sl_price, exchange_sl_order_id,
                initial_tps, remaining_tps, move_sl_to_be_after_tp_index, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            'sig1', 'BTCUSDT', 'long', status, 90.0, 100.0, total_qty, avg_price, 85.0, sl_price,
            sl_order_id, initial_tps_json, remaining_tps_json, move_sl_idx, now_utc_iso, now_utc_iso
        ))
        trade_id = cursor.lastrowid
        conn.commit()
    finally:
        conn.close()
    return trade_id

# === Группа тестов для функции reconcile_and_manage ===

@pytest.mark.asyncio
async def test_reconcile_pending_to_active(mock_bybit_client):
    """
    Тестирует переход сделки из PENDING_ENTRY в ACTIVE.
    """
    # 1. Подготовка: создаем сделку и ордер в чистой БД.
    # Фикстура `setup_for_every_test` гарантирует, что БД чиста.
    trade_id = create_test_trade_in_db(status='PENDING_ENTRY')
    
    conn = get_db_connection()
    try:
        # Используем уникальный ID для ордера, который не будет конфликтовать
        conn.execute("INSERT INTO entry_orders (trade_id, exchange_order_id, status) VALUES (?, ?, 'open')", (trade_id, f"entry_order_{trade_id}"))
        conn.commit()
        trade_before = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    finally:
        conn.close()

    # 2. Симуляция: "на бирже" появилась открытая позиция
    live_position_mock = {
        'symbol': 'BTCUSDT',
        'entryPrice': '95.5',
        'contracts': '0.5',
        'markPrice': '96.0'
    }
    
    # 3. Действие: вызываем тестируемую функцию
    await reconcile_and_manage(trade_before, live_position_mock, mock_bybit_client)

    # 4. Проверка результата
    conn = get_db_connection()
    try:
        trade_after = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    finally:
        conn.close()
    
    assert trade_after['status'] == 'ACTIVE'
    assert trade_after['avg_entry_price'] == 95.5
    assert trade_after['executed_qty'] == 0.5
    # mock_bybit_client из conftest.py возвращает 'stop_loss_order_1'
    assert trade_after['exchange_sl_order_id'] == 'stop_loss_order_1' 
    mock_bybit_client.cancel_order.assert_called_once_with(f"entry_order_{trade_id}", 'BTCUSDT')

@pytest.mark.asyncio
async def test_reconcile_active_to_closed(mock_bybit_client):
    """
    Тестирует переход сделки из ACTIVE в CLOSED.
    """
    trade_id = create_test_trade_in_db(status='ACTIVE', avg_price=95.0)
    
    conn = get_db_connection()
    trade_before = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    live_position_mock = None
    
    await reconcile_and_manage(trade_before, live_position_mock, mock_bybit_client)

    conn = get_db_connection()
    trade_after = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    # Теперь эта проверка должна пройти, так как get_realized_pnl не вызовет ошибку
    assert trade_after['status'] == 'CLOSED'
    assert trade_after['close_reason'] is not None

@pytest.mark.asyncio
async def test_reconcile_moves_sl_to_breakeven(mock_bybit_client):
    """
    Тестирует перемещение стоп-лосса в безубыток.
    """
    # --- ИСПРАВЛЕНИЕ ОШИБКИ ---
    # Заменяем pytest.AsyncMock на AsyncMock из unittest.mock
    mock_bybit_client.edit_order = AsyncMock(return_value={"id": "sl_edited_456"})
    # ---------------------------
    
    trade_id = create_test_trade_in_db(
        status='ACTIVE', avg_price=95.0, sl_price=85.0,
        sl_order_id='sl_initial_123', remaining_tps='[120]', move_sl_idx=1
    )
    
    conn = get_db_connection()
    trade_before = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    live_position_mock = {
        'symbol': 'BTCUSDT', 'entryPrice': '95.0',
        'contracts': '0.5', 'markPrice': '115.0'
    }
    
    await reconcile_and_manage(trade_before, live_position_mock, mock_bybit_client)

    conn = get_db_connection()
    trade_after = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    assert trade_after['current_sl_price'] == trade_after['avg_entry_price']
    
    mock_bybit_client.edit_order.assert_called_once_with(
        'sl_initial_123', 'BTCUSDT', 95.0
    )

🔹 File: tests/test_risk_controls.py
----------------------------------------------
# file: tests/test_risk_controls.py
import pytest
import numpy as np
from datetime import date
from fastapi import HTTPException

# Импортируем тестируемые функции
from risk_controls import check_daily_drawdown, update_pnl
# Импортируем утилиту для получения соединения
from db_utils import get_db_connection

# Вспомогательная функция для тестирования декоратора
@check_daily_drawdown(max_loss_pct=0.03)
async def dummy_protected_function():
    return {"status": "allowed"}

# ==================== ДИАГНОСТИЧЕСКИЕ ТЕСТЫ ====================
def test_initial_state_is_clean():
    """
    Этот тест должен выполняться ПЕРВЫМ.
    Он проверяет, что таблица daily_pnl пуста в начале.
    """
    print("\n[DIAGNOSTIC] Running test_initial_state_is_clean...")
    conn = get_db_connection()
    try:
        pnl_record = conn.execute("SELECT * FROM daily_pnl").fetchone()
    finally:
        conn.close()
    
    assert pnl_record is None, "ДИАГНОСТИКА: Таблица daily_pnl НЕ пуста в начале!"

# === Группа тестов для декоратора check_daily_drawdown ===

@pytest.mark.asyncio
async def test_dd_allows_when_no_pnl():
    """Проверяет: разрешает вход, если PnL за сегодня еще нет."""
    # БД чистая благодаря фикстуре, поэтому PnL = 0
    response = await dummy_protected_function()
    assert response == {"status": "allowed"}

@pytest.mark.asyncio
async def test_dd_allows_when_within_limit():
    """Проверяет: разрешает вход, если убыток в пределах лимита."""
    conn = get_db_connection()
    try:
        update_pnl(conn, -10.0) # Записываем PnL = -10
    finally:
        conn.close()
    
    # dummy_protected_function увидит PnL = -10.0, что меньше лимита
    response = await dummy_protected_function()
    assert response == {"status": "allowed"}

@pytest.mark.asyncio
async def test_dd_rejects_when_at_limit():
    """Проверяет: блокирует вход, если убыток равен лимиту."""
    conn = get_db_connection()
    try:
        update_pnl(conn, -30.0) # Записываем PnL = -30 (равен лимиту)
    finally:
        conn.close()
        
    with pytest.raises(HTTPException) as exc_info:
        await dummy_protected_function()
    assert exc_info.value.status_code == 429

@pytest.mark.asyncio
async def test_dd_rejects_when_exceeds_limit():
    """Проверяет: блокирует вход, если убыток превышает лимит."""
    conn = get_db_connection()
    try:
        update_pnl(conn, -35.0) # Записываем PnL = -35
    finally:
        conn.close()
        
    with pytest.raises(HTTPException) as exc_info:
        await dummy_protected_function()
        
    assert exc_info.value.status_code == 429
    # Проверяем, что в сообщении об ошибке указан правильный PnL
    assert "-35.00" in exc_info.value.detail


# === Группа тестов для функции update_pnl ===

def test_update_pnl_accumulates_correctly():
    """Проверяет, что update_pnl корректно суммирует PnL за день."""
    conn = get_db_connection()
    try:
        # Эти операции происходят в чистой базе данных
        update_pnl(conn, 10.5)
        update_pnl(conn, -5.5)
        update_pnl(conn, 2.0)
        row = conn.execute("SELECT realised_pnl FROM daily_pnl WHERE trade_date = ?", (date.today(),)).fetchone()
    finally:
        conn.close()

    assert row is not None
    pnl = row['realised_pnl']
    # Значение будет ровно 7.0, так как нет "грязных" данных из других тестов
    assert np.isclose(pnl, 7.0)

def test_final_state_is_also_clean():
    """
    Этот тест должен выполняться ПОСЛЕДНИМ в этом файле.
    Он проверяет, осталось ли что-то в таблице после других тестов.
    """
    print("\n[DIAGNOSTIC] Running test_final_state_is_also_clean...")
    conn = get_db_connection()
    try:
        pnl_record = conn.execute("SELECT * FROM daily_pnl").fetchone()
    finally:
        conn.close()
    
    assert pnl_record is None, "ДИАГНОСТИКА: Таблица daily_pnl НЕ пуста в конце!"
# =================================================================

🔹 File: tests/test_risk_sizer.py
----------------------------------------------
# File: tests/test_risk_sizer.py
import pytest
from risk_sizer import calculate_position_size

def test_calculate_position_size_btc():
    # step для BTC = 0.001
    size = calculate_position_size(60000.0, 59000.0, 1000.0, amount_precision_step=0.001)
    assert size == 0.01

def test_calculate_position_size_altcoin():
    # step для SOL = 0.01
    size = calculate_position_size(150.0, 145.0, 1000.0, amount_precision_step=0.01)
    assert size == 2.0

def test_calculate_position_size_shibcoin():
    # step для SHIB = 1 (целое число)
    size = calculate_position_size(0.000025, 0.000024, 1000.0, amount_precision_step=1)
    # ИЗМЕНЕНО: round(10000000.0) == 10000000
    assert size == 10000000

def test_calculate_position_size_zero_balance():
    size = calculate_position_size(60000.0, 59000.0, 0.0, amount_precision_step=0.001)
    assert size == 0.0

def test_calculate_position_size_zero_price_diff():
    size = calculate_position_size(60000.0, 60000.0, 1000.0, amount_precision_step=0.001)
    assert size == 0.0


🔹 File: tests/test_signal_parser.py
----------------------------------------------
# file: tests/test_signal_parser.py
import pytest
from signal_parser import parse_pentagon_signal

# Пример успешного сигнала
VALID_SIGNAL_TEXT = """
🔴пробую шорт 109200-110500 и риском 0.5% (1/2) стоп над 111500, после 2ого тейка в бу
Цели: 
109000-108800-108600
"""

# Пример сигнала с ошибкой (нет тейков)
INVALID_SIGNAL_TEXT = "🔴пробую шорт 109200-110500 и риском 0.5% (1/2) стоп над 111500"

def test_parse_valid_signal_success():
    """Тестирует успешный парсинг корректного сигнала."""
    instruction = parse_pentagon_signal(VALID_SIGNAL_TEXT)
    
    assert instruction is not None
    assert instruction.side == 'short'
    assert instruction.entry_start == 109200.0
    assert instruction.entry_end == 110500.0
    assert instruction.stop_loss == 111500.0
    assert instruction.risk_pct == pytest.approx(0.005)
    assert instruction.size_fraction == pytest.approx(0.5)
    assert instruction.take_profits == [109000.0, 108800.0, 108600.0]

def test_parse_invalid_signal_returns_none():
    """Тестирует, что парсер возвращает None для некорректного сигнала."""
    instruction = parse_pentagon_signal(INVALID_SIGNAL_TEXT)
    assert instruction is None

def test_parse_empty_string_returns_none():
    """Тестирует обработку пустой строки."""
    instruction = parse_pentagon_signal("")
    assert instruction is None

🔹 File: tests/test_spring_model.py
----------------------------------------------
import pytest
import pandas as pd
import numpy as np
from spring_model import bounce_prob

@pytest.fixture
def synthetic_bars():
    # Synthetic data where mu=100, sigma=5
    # Lower BB = 100 - 2*5 = 90
    # Upper BB = 100 + 2*5 = 110
    np.random.seed(42)
    data = np.concatenate([np.random.normal(100, 5, 19), [100]])
    return pd.DataFrame({'close': data})

def test_long_bounce_strong(synthetic_bars):
    # Price is far below the lower BB, expecting high probability
    prob = bounce_prob(synthetic_bars, 'long', price=80, bb_std_dev=2.0)
    assert prob > 0.5
    assert prob <= 1.0

def test_long_bounce_zero(synthetic_bars):
    # Price is inside the bands, expecting zero probability
    prob = bounce_prob(synthetic_bars, 'long', price=95, bb_std_dev=2.0)
    assert prob == 0.0

def test_short_bounce_strong(synthetic_bars):
    # Price is far above the upper BB, expecting high probability
    prob = bounce_prob(synthetic_bars, 'short', price=120, bb_std_dev=2.0)
    assert prob > 0.5
    assert prob <= 1.0

def test_short_bounce_zero(synthetic_bars):
    # Price is inside the bands, expecting zero probability
    prob = bounce_prob(synthetic_bars, 'short', price=105, bb_std_dev=2.0)
    assert prob == 0.0

def test_edge_case_not_enough_data():
    bars = pd.DataFrame({'close': [100, 101]})
    prob = bounce_prob(bars, 'long', price=95, bb_window=20)
    assert prob == 0.0

def test_edge_case_zero_volatility():
    bars = pd.DataFrame({'close': [100] * 20})
    prob = bounce_prob(bars, 'long', price=95, bb_window=20)
    assert prob == 0.0

def test_invalid_side(synthetic_bars):
    with pytest.raises(ValueError):
        bounce_prob(synthetic_bars, 'sideways', price=100)

🔹 File: tests/test_trade_logger.py
----------------------------------------------
# file: tests/test_trade_logger.py
import pytest
import json

# Импортируем тестируемые функции
from trade_logger import log_signal, log_trade_execution, log_event
from db_utils import get_db_connection

# Эта строка применит фикстуру clean_db ко всем тестам в файле
pytestmark = pytest.mark.usefixtures("setup_for_every_test")

# Добавляем фикстуру db_conn в аргументы теста
def test_log_signal_creates_correct_record(): # REMOVE db_conn
    """
    Tests that log_signal correctly creates a record in the DB.
    """
    signal_data = {'symbol': 'BTCUSDT', 'side': 'long'}
    log_signal(signal_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = 'SIGNAL_RECEIVED'").fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    assert log_entry['event_type'] == 'SIGNAL_RECEIVED'
    payload = json.loads(log_entry['payload_json'])
    assert payload['symbol'] == 'BTCUSDT'


def test_log_successful_trade_execution(): # REMOVE db_conn
    """
    Tests logging of a successful order placement.
    """
    order_data = {'id': '123', 'error': None}
    log_trade_execution(order_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = 'ORDER_PLACED'").fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    assert log_entry['event_type'] == 'ORDER_PLACED'


def test_log_failed_trade_execution(): # REMOVE db_conn
    """
    Tests logging of a failed order placement.
    """
    order_data = {'error': 'InsufficientFunds'}
    log_trade_execution(order_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = 'ORDER_FAILED'").fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    assert log_entry['event_type'] == 'ORDER_FAILED'


def test_log_event_generic(): # REMOVE db_conn
    """Tests the generic log_event function."""
    event_type = "CUSTOM_TEST_EVENT"
    payload_data = {"key": "value"}
    log_event(event_type, payload_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = ?", (event_type,)).fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    payload = json.loads(log_entry['payload_json'])
    assert payload['key'] == "value"

🔹 File: trade_logger.py
----------------------------------------------
# file: trade_logger.py
import json
from datetime import datetime, timezone

# Импортируем наш унифицированный коннектор к БД
from db_utils import get_db_connection

def log_event(event_type: str, payload: dict):
    """
    Универсальная функция для логирования любого события в системе.
    Записывает событие в таблицу 'trade_log'.

    Args:
        event_type (str): Тип события (например, 'SIGNAL_RECEIVED', 'ORDER_PLACED').
        payload (dict): Словарь с дополнительными данными о событии.
    """
    try:
        conn = get_db_connection()
        
        # Преобразуем все значения в payload в строки, чтобы избежать ошибок сериализации
        # сложных объектов (например, Decimal) и обеспечить консистентность.
        serializable_payload = {k: str(v) for k, v in payload.items()}
        payload_str = json.dumps(serializable_payload)

        record = {
            "timestamp_utc": datetime.now(timezone.utc).isoformat(timespec='microseconds'),
            "event_type": event_type,
            "payload_json": payload_str
        }
        
        # Используем `with conn:` для автоматического коммита или отката транзакции
        with conn:
            conn.execute(
                "INSERT INTO trade_log (timestamp_utc, event_type, payload_json) VALUES (:timestamp_utc, :event_type, :payload_json)",
                record
            )
        
        print(f"[LOG] Event: {event_type} | Payload: {payload}")

    except Exception as e:
        # Критично важно не "уронить" приложение, если логирование не удалось.
        # Просто выводим ошибку в консоль.
        print(f"[LOGGING_ERROR] Failed to log event '{event_type}'. Error: {e}")
    finally:
        if 'conn' in locals() and conn:
            conn.close()


def log_signal(signal: dict):
    """
    Специализированная функция-хелпер для логирования входящего торгового сигнала.
    """
    log_event("SIGNAL_RECEIVED", payload=signal)


def log_trade_execution(order_result: dict):
    """
    Специализированная функция-хелпер для логирования результата размещения ордера.
    Автоматически определяет тип события (успех/неудача) по наличию ключа 'error'.
    """
    # Создаем копию, чтобы не изменять оригинальный объект, который может еще использоваться
    payload = order_result.copy()
    
    # Определяем тип события
    # Если в результате есть ключ 'error' и он не None/пустой, считаем это ошибкой
    if payload.get('error'):
        event_type = "ORDER_FAILED"
    else:
        event_type = "ORDER_PLACED"
        
    log_event(event_type, payload=payload)