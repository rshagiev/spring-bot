üß† Python Project Dump for LLM ‚Äî spring-bot
üìÖ Date: Wed Jul  9 01:10:46 +05 2025
üìÇ Path: /Users/rshagiev/PycharmProjects/spring-bot
==============================================


üìÅ Project Structure (tree -L 3):
----------------------------------------------
.
‚îú‚îÄ‚îÄ backtest_runner.py
‚îú‚îÄ‚îÄ bybit_wrapper.py
‚îú‚îÄ‚îÄ check_keys.py
‚îú‚îÄ‚îÄ dashboard.py
‚îú‚îÄ‚îÄ dump_python_files.sh
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ project_dump.txt
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ risk_controls.py
‚îú‚îÄ‚îÄ risk_sizer.py
‚îú‚îÄ‚îÄ spring_model.py
‚îú‚îÄ‚îÄ tests
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ conftest.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_api_execute.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_api_utils.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_backtest_runner.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_bybit_wrapper.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_risk_controls.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_risk_sizer.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_spring_model.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_trade_logger.py
‚îú‚îÄ‚îÄ trade_logger.py
‚îî‚îÄ‚îÄ trades.sqlite

2 directories, 24 files


üì¶ requirements.txt:
----------------------------------------------
# Core Logic & Data
pandas
numpy

# API & Web Services
fastapi
uvicorn
aiofiles

# Exchange Integration
ccxt==4.*

# Database
sqlite-utils==3.*

# Testing
pytest
pytest-asyncio
pytest-mock
httpx 

# UI & Dashboard
streamlit
streamlit-autorefresh
python-dotenv

üìù Python Files:
==============================================


üîπ File: backtest_runner.py
----------------------------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from itertools import product
from spring_model import bounce_prob

# --- Constants ---
INITIAL_EQUITY = 1000.0
RISK_PER_TRADE_PCT = 0.01
FIXED_RR_RATIO = 1.5
PROB_THRESHOLD = 0.5

def run_backtest(price_df, signals_df, bb_window, bb_std_dev):
    equity = INITIAL_EQUITY
    equity_curve = [INITIAL_EQUITY]
    trades = []

    for _, signal in signals_df.iterrows():
        # Find the price data available right before the signal
        bars = price_df[price_df['ts'] < signal['ts']].tail(bb_window)
        if len(bars) < bb_window:
            continue

        # 1. Filter signal through the spring model
        prob = bounce_prob(bars, signal['side'], signal['entry'], bb_window, bb_std_dev)
        if prob < PROB_THRESHOLD:
            continue

        # 2. Size the trade
        risk_per_trade_usd = equity * RISK_PER_TRADE_PCT
        stop_loss_dist = abs(signal['entry'] - signal['sl'])
        if stop_loss_dist == 0: continue
        position_size = risk_per_trade_usd / stop_loss_dist

        # 3. Determine TP based on fixed R:R
        take_profit_dist = stop_loss_dist * FIXED_RR_RATIO
        if signal['side'] == 'long':
            tp_price = signal['entry'] + take_profit_dist
            sl_price = signal['sl']
        else:
            tp_price = signal['entry'] - take_profit_dist
            sl_price = signal['sl']

        # 4. Simulate trade execution
        trade_data = price_df[price_df['ts'] >= signal['ts']]
        pnl = 0
        outcome = 'No fill'
        for _, row in trade_data.iterrows():
            if signal['side'] == 'long':
                if row['high'] >= tp_price:
                    pnl = (tp_price - signal['entry']) * position_size
                    outcome = 'TP'
                    break
                if row['low'] <= sl_price:
                    pnl = (sl_price - signal['entry']) * position_size
                    outcome = 'SL'
                    break
            else: # short
                if row['low'] <= tp_price:
                    pnl = (signal['entry'] - tp_price) * position_size
                    outcome = 'TP'
                    break
                if row['high'] >= sl_price:
                    pnl = (signal['entry'] - sl_price) * position_size
                    outcome = 'SL'
                    break

        if outcome in ['TP', 'SL']:
            equity += pnl
            equity_curve.append(equity)
            trades.append({'pnl': pnl, 'outcome': outcome})
    
    return equity_curve, trades

def calculate_metrics(equity_curve, num_days):
    returns = pd.Series(equity_curve).pct_change().dropna()
    total_return = (equity_curve[-1] / INITIAL_EQUITY) - 1
    
    # Max Drawdown
    rolling_max = pd.Series(equity_curve).cummax()
    drawdown = (pd.Series(equity_curve) - rolling_max) / rolling_max
    max_drawdown = drawdown.min()
    
    # Sharpe Ratio (annualized)
    daily_returns = returns[returns != 0]
    if len(daily_returns) > 1 and daily_returns.std() != 0:
        # NOTE: This is an approximate annualization, assuming trades are somewhat evenly distributed.
        # It's suitable for comparing parameters but is not a perfectly rigorous Sharpe calculation.
        sharpe_ratio = (daily_returns.mean() / daily_returns.std()) * np.sqrt(365 * 24 * 60 / (num_days * 24 * 60 / len(daily_returns)) )
    else:
        sharpe_ratio = 0

    return total_return, max_drawdown, sharpe_ratio

if __name__ == '__main__':
    # 1. Load data
    try:
        price_df = pd.read_csv('btc_1m.csv', names=['ts', 'open', 'high', 'low', 'close', 'volume'])
        signals_df = pd.read_csv('signals.csv') # ts, side, entry, sl, tp
    except FileNotFoundError as e:
        print(f"Error: {e}. Make sure 'btc_1m.csv' (no header) and 'signals.csv' are present.")
        exit()

    # Ensure timestamps are numeric for comparison (OS-agnostic method)
    price_df['ts'] = pd.to_datetime(price_df['ts']).view('int64') // 10**9
    signals_df['ts'] = pd.to_datetime(signals_df['ts']).view('int64') // 10**9
    num_days = (price_df['ts'].max() - price_df['ts'].min()) / (60 * 60 * 24)

    # 5. Parameter Grid Search
    bb_windows = [10, 20, 30]
    bb_multipliers = [1.5, 2.0, 2.5]
    results = []

    print("Running backtest grid search...")
    for window, mult in product(bb_windows, bb_multipliers):
        equity_curve, trades = run_backtest(price_df, signals_df, window, mult)
        if len(equity_curve) > 1:
            total_r, max_dd, sharpe = calculate_metrics(equity_curve, num_days)
            results.append(((window, mult), total_r, max_dd, sharpe, len(trades)))
    
    # Print results
    print("\n--- Backtest Results ---")
    print(f"{'Params (win, std)':<20} | {'Total Return':>15} | {'Max Drawdown':>15} | {'Sharpe Ratio':>15} | {'Num Trades':>12}")
    print('-'*85)
    sorted_results = sorted(results, key=lambda x: x[3], reverse=True) # Sort by Sharpe
    for params, total_r, max_dd, sharpe, num_trades in sorted_results:
        print(f"{str(params):<20} | {total_r:>14.2%} | {max_dd:>14.2%} | {sharpe:>15.2f} | {num_trades:>12}")

    # Plot the best result
    if sorted_results:
        best_params = sorted_results[0][0]
        print(f"\nPlotting equity curve for best params: {best_params}")
        best_equity_curve, _ = run_backtest(price_df, signals_df, best_params[0], best_params[1])
        plt.figure(figsize=(12, 6))
        plt.plot(best_equity_curve)
        plt.title(f'Equity Curve - Best Params: {best_params} (Sharpe: {sorted_results[0][3]:.2f})')
        plt.xlabel('Trade Number')
        plt.ylabel('Equity (USDT)')
        plt.grid(True)
        plt.savefig('equity_curve.png')
        print("Saved equity curve to equity_curve.png")

üîπ File: bybit_wrapper.py
----------------------------------------------
import ccxt.async_support as ccxt
import os
from trade_logger import log_trade_execution, log_event

class AsyncBybitWrapper:
    def __init__(self, api_key: str, secret_key: str, testnet: bool = True):
        if not api_key or not secret_key:
            raise ValueError("API key and secret must be provided.")
        
        self.testnet = testnet
        self.exchange = ccxt.bybit({
            'apiKey': api_key,
            'secret': secret_key,
            'options': {'defaultType': 'swap'},
        })
        if self.testnet:
            self.exchange.set_sandbox_mode(True)

    async def init(self):
        try:
            await self.exchange.load_markets()
            print(f"Successfully connected to Bybit. Sandbox mode: {self.testnet}")
        except Exception as e:
            await self.close()
            raise

    async def close(self):
        if self.exchange:
            await self.exchange.close()

    # --- –î–û–ë–ê–í–¨–¢–ï –≠–¢–ò –î–í–ê –ú–ï–¢–û–î–ê ---
    async def set_leverage(self, symbol: str, leverage: int):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∫—Ä–µ–¥–∏—Ç–Ω–æ–µ –ø–ª–µ—á–æ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞."""
        try:
            await self.exchange.set_leverage(leverage, symbol)
            log_event("LEVERAGE_SET", {"symbol": symbol, "leverage": leverage})
        except Exception as e:
            log_event("LEVERAGE_ERROR", {"symbol": symbol, "error": str(e)})
            # –ú–æ–∂–Ω–æ –Ω–µ –∫–∏–¥–∞—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, –µ—Å–ª–∏ –±–∏—Ä–∂–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ç–æ—Ä–≥–æ–≤–∞—Ç—å –∏ —Ç–∞–∫
            print(f"Warning: Failed to set leverage for {symbol}: {e}")

    async def set_margin_mode(self, symbol: str, margin_mode: str):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ä–µ–∂–∏–º –º–∞—Ä–∂–∏ ('cross' –∏–ª–∏ 'isolated')."""
        try:
            unified_symbol = symbol.split(':')[0]
            await self.exchange.set_margin_mode(margin_mode, unified_symbol, params={'settleCoin': 'USDT'})
            log_event("MARGIN_MODE_SET", {"symbol": symbol, "mode": margin_mode})
        except Exception as e:
            log_event("MARGIN_MODE_ERROR", {"symbol": symbol, "error": str(e)})
            print(f"Warning: Failed to set margin mode for {symbol}: {e}")
    # ------------------------------------

    def get_market_precision(self, symbol: str) -> dict:
        try:
            market = self.exchange.market(symbol)
            return {'price': market['precision']['price'], 'amount': market['precision']['amount']}
        except (ccxt.BadSymbol, KeyError):
            return None

    async def get_usdt_balance(self) -> float:
        try:
            balance = await self.exchange.fetch_balance()
            return float(balance.get('USDT', {}).get('total', 0.0))
        except Exception as e:
            return 0.0

    async def fetch_open_positions(self) -> dict:
        try:
            positions = await self.exchange.fetch_positions()
            return {p['info']['symbol']: p for p in positions if float(p.get('contracts', 0)) != 0}
        except Exception:
            return {}
    
    # --- –î–û–ë–ê–í–¨–¢–ï –≠–¢–û–¢ –ú–ï–¢–û–î ---
    async def fetch_ticker_price(self, symbol: str) -> float:
        """–ü–æ–ª—É—á–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω—é—é —Ü–µ–Ω—É –¥–ª—è —Ç–∏–∫–µ—Ä–∞."""
        try:
            ticker = await self.exchange.fetch_ticker(symbol)
            return float(ticker['last'])
        except Exception as e:
            print(f"Error fetching ticker for {symbol}: {e}")
            return 0.0
    # ---------------------------

    async def create_market_order_with_sl(self, symbol: str, side: str, amount: float, stop_loss_price: float) -> dict:
        params = {'stopLoss': stop_loss_price}
        try:
            order = await self.exchange.create_order(symbol, 'market', side, amount, params=params)
            log_trade_execution(order)
            return order
        except Exception as e:
            error_payload = {'symbol': symbol, 'error': str(e)}
            log_trade_execution(error_payload)
            return error_payload

üîπ File: check_keys.py
----------------------------------------------
# File: check_keys.py (–í–ï–†–°–ò–Ø –° –•–ê–†–î–ö–û–î–û–ú)
import os
import asyncio
import ccxt.async_support as ccxt
# from dotenv import load_dotenv # –ë–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–æ

async def main():
    # load_dotenv() # –ë–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–æ
    
    # --- –í–†–ï–ú–ï–ù–ù–û –í–°–¢–ê–í–õ–Ø–ï–ú –ö–õ–Æ–ß–ò –ü–†–Ø–ú–û –°–Æ–î–ê ---
    api_key = "Xyo4o0isLLDU1vaRlN"
    secret = "L4BnWcl26eeeWYT3keMiKLtnFwmKm0tKQoJp"
    # ---------------------------------------------

    print(f"--- Checking Keys (Hardcoded) ---")
    print(f"API Key used: {api_key}")
    print("-" * 20)

    exchange = ccxt.bybit({
        'apiKey': api_key,
        'secret': secret,
    })
    exchange.set_sandbox_mode(True)

    try:
        print("Attempting to fetch balance...")
        balance = await exchange.fetch_balance()
        print("\nSUCCESS! Connection is working.")
        print(f"Available USDT Balance: {balance.get('USDT', {}).get('free', 0.0)}")
    except ccxt.AuthenticationError as e:
        print(f"\nERROR: Authentication failed. Bybit says: {e}")
        print("This confirms the issue is with the keys themselves or their permissions on Bybit's side.")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
    finally:
        await exchange.close()

if __name__ == "__main__":
    asyncio.run(main())

üîπ File: dashboard.py
----------------------------------------------
# File: dashboard.py (–§–ò–ù–ê–õ–¨–ù–ê–Ø –†–ê–ë–û–ß–ê–Ø –í–ï–†–°–ò–Ø)
import streamlit as st
import pandas as pd
import requests
import sqlite3 # <-- –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π sqlite3
import sqlite_utils
import json
import os
from streamlit_autorefresh import st_autorefresh

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
API_BASE_URL = os.getenv("BOT_API_URL", "http://127.0.0.1:8000")
DB_FILE = os.getenv("TRADE_DB", "trades.sqlite")
REFRESH_INTERVAL_SECONDS = 5

st.set_page_config(
    page_title="Trading Bot Dashboard",
    layout="wide",
)

# --- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã ---
st_autorefresh(interval=REFRESH_INTERVAL_SECONDS * 1000, key="dashboard_refresh")

# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö ---
@st.cache_resource
def get_db_conn():
    """
    –ö–µ—à–∏—Ä—É–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î.
    –ò–ó–ú–ï–ù–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º sqlite3 –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.
    """
    try:
        # –°–æ–∑–¥–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –æ—Ç–∫–ª—é—á–∞—è –ø—Ä–æ–≤–µ—Ä–∫—É –ø–æ—Ç–æ–∫–∞
        conn = sqlite3.connect(DB_FILE, check_same_thread=False)
        # –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –µ–≥–æ –≤ –æ–±—ä–µ–∫—Ç sqlite_utils
        return sqlite_utils.Database(conn)
    except Exception as e:
        st.error(f"Failed to connect to database: {DB_FILE}. Error: {e}")
        return None

@st.cache_data(ttl=REFRESH_INTERVAL_SECONDS)
def get_open_positions():
    """–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ —Å –Ω–∞—à–µ–≥–æ API."""
    try:
        response = requests.get(f"{API_BASE_URL}/open_positions")
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException:
        return {}

@st.cache_data(ttl=REFRESH_INTERVAL_SECONDS)
def get_event_log(limit=20):
    """–ß–∏—Ç–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è –∏–∑ –ª–æ–≥–∞."""
    db = get_db_conn()
    if db is None or 'trade_log' not in db.table_names():
        return []
    try:
        return list(db.table('trade_log').rows_where(order_by='id DESC', limit=limit))
    except Exception:
        return []

# --- –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞—à–±–æ—Ä–¥–∞ ---
st.title("ü§ñ LLM-Driven Trading Bot Dashboard")

# --- –°–µ–∫—Ü–∏—è 1: –û—Ç–∫—Ä—ã—Ç—ã–µ –ü–æ–∑–∏—Ü–∏–∏ ---
st.subheader("üìä Open Positions")
positions_data = get_open_positions()
if positions_data:
    positions_df = pd.DataFrame(list(positions_data.values()))
    display_cols = {
        'symbol': 'Symbol', 'side': 'Side', 'contracts': 'Size',
        'entryPrice': 'Entry', 'markPrice': 'Mark', 'unrealizedPnl': 'uPNL'
    }
    existing_cols = [col for col in display_cols.keys() if col in positions_df.columns]
    if existing_cols:
        filtered_df = positions_df[existing_cols].rename(columns=display_cols)
        st.dataframe(filtered_df, use_container_width=True, hide_index=True)
    else:
        st.info("No open positions with required data.")
else:
    st.info("No open positions or API not reachable.")

# --- –°–µ–∫—Ü–∏—è 2: –ñ—É—Ä–Ω–∞–ª –°–æ–±—ã—Ç–∏–π ---
st.subheader("üìú Recent Events")
log_data = get_event_log()
if log_data:
    log_df = pd.DataFrame(log_data)
    if 'payload_json' in log_df.columns:
        log_df['timestamp_utc'] = pd.to_datetime(log_df['timestamp_utc']).dt.strftime('%Y-%m-%d %H:%M:%S')
        def pretty_payload(payload_str):
            try: return json.loads(payload_str)
            except: return payload_str
        log_df['payload'] = log_df['payload_json'].apply(pretty_payload)
        st.dataframe(
            log_df[['timestamp_utc', 'event_type', 'payload']],
            use_container_width=True,
            hide_index=True
        )
    else:
        st.dataframe(log_df, use_container_width=True, hide_index=True)
else:
    st.warning("Event log is empty or database not found.")

# --- –°–µ–∫—Ü–∏—è 3: –ö—Ä–∏–≤–∞—è –∫–∞–ø–∏—Ç–∞–ª–∞ (–∑–∞–≥–ª—É—à–∫–∞) ---
st.subheader("üìà Equity Curve (placeholder)")
st.info("Equity curve will be implemented once PnL data is logged upon trade closure.")

üîπ File: main.py
----------------------------------------------
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Any
import time
import os
from dotenv import load_dotenv

# --- –®–∞–≥ 1: –Ø–≤–Ω–æ –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env —Ñ–∞–π–ª–∞ ---
load_dotenv()
MAX_ENTRY_DEVIATION_PCT = 0.005  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã –≤—Ö–æ–¥–∞ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (0.5%)

# --- –®–∞–≥ 2: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—à–∏ –º–æ–¥—É–ª–∏ –ü–û–°–õ–ï –∑–∞–≥—Ä—É–∑–∫–∏ .env ---
from bybit_wrapper import AsyncBybitWrapper
from risk_sizer import calculate_position_size
from risk_controls import check_daily_drawdown, initialize_pnl_table
from trade_logger import log_signal, log_event

# --- Pydantic Models for API validation ---
class Signal(BaseModel):
    symbol: str
    side: str
    entry: float
    sl: float
    tp: float

# --- FastAPI App Initialization ---
API_KEY = os.getenv("BYBIT_KEY")
API_SECRET = os.getenv("BYBIT_SECRET")

if not API_KEY or not API_SECRET:
    print("FATAL ERROR: BYBIT_KEY and/or BYBIT_SECRET not found. Please check your .env file.")
    exit()

app = FastAPI(title="LLM-Driven Trading Bot", version="0.2.0")
bybit_client = AsyncBybitWrapper(api_key=API_KEY, secret_key=API_SECRET, testnet=True)


@app.on_event("startup")
async def startup_event():
    """Initializes services when the application starts."""
    initialize_pnl_table()
    await bybit_client.init()

@app.on_event("shutdown")
async def shutdown_event():
    """Closes the Bybit client connection when the application shuts down."""
    await bybit_client.close()


# --- API Endpoints ---
@app.post("/execute")
@check_daily_drawdown(max_loss_pct=0.03)
async def execute_trade(signal: Signal):
    """
    Main endpoint for receiving and processing a trading signal.
    Spring Model filter is DISABLED for this version.
    """
    log_signal(signal.model_dump())
    
    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å–∏–º–≤–æ–ª –¥–ª—è ccxt, e.g., 'BTCUSDT' -> 'BTC/USDT:USDT'
    ccxt_symbol = f"{signal.symbol.replace('USDT', '')}/USDT:USDT"

    # --- –ù–û–í–´–ô –®–ê–ì: –ü–†–û–í–ï–†–ö–ê –¶–ï–ù–´ –í–•–û–î–ê ---
    current_price = await bybit_client.fetch_ticker_price(ccxt_symbol)
    if current_price == 0:
        reason = {"reason": "failed_to_fetch_current_price"}
        log_event("TRADE_REJECTED", reason)
        raise HTTPException(status_code=503, detail=reason)

    deviation = abs(current_price - signal.entry) / signal.entry
    if deviation > MAX_ENTRY_DEVIATION_PCT:
        reason = {
            "reason": "price_deviation_too_high",
            "current_price": current_price,
            "signal_entry": signal.entry,
            "deviation_pct": deviation * 100
        }
        log_event("TRADE_REJECTED", reason)
        raise HTTPException(status_code=400, detail=reason)
    # ------------------------------------

    # –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º —Ç–æ—á–Ω–æ—Å—Ç—å –¥–ª—è —Å–∏–º–≤–æ–ª–∞
    try:
        precision = bybit_client.get_market_precision(ccxt_symbol)
        if precision is None:
            raise ValueError(f"Precision info not found for {ccxt_symbol}")
        amount_precision_step = float(precision['amount'])
    except Exception as e:
        log_event("TRADE_REJECTED", {"reason": "precision_error", "details": str(e)})
        raise HTTPException(status_code=404, detail=f"Market symbol '{ccxt_symbol}' not found or precision not available: {e}")

    # –®–∞–≥ 2: –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏
    equity = await bybit_client.get_usdt_balance()
    qty = calculate_position_size(
        entry_price=signal.entry,
        stop_loss_price=signal.sl,
        equity=equity,
        amount_precision_step=amount_precision_step
    )
    
    if qty <= 0:
        reason = {"reason": "risk_sizer_returned_zero_qty", "calculated_qty": qty, "equity": equity}
        log_event("TRADE_REJECTED", reason)
        raise HTTPException(status_code=400, detail=reason)

    # –®–∞–≥ 3: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ä–∏—Å–∫–∞
    await bybit_client.set_margin_mode(ccxt_symbol, 'isolated')
    await bybit_client.set_leverage(ccxt_symbol, 10)

    # –®–∞–≥ 4: –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞
    order = await bybit_client.create_market_order_with_sl(
        symbol=ccxt_symbol, 
        side='buy' if signal.side == 'long' else 'sell',
        amount=qty,
        stop_loss_price=signal.sl
    )

    if 'error' in order:
        # –û—à–∏–±–∫–∞ —É–∂–µ –∑–∞–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∞ –≤–Ω—É—Ç—Ä–∏ wrapper'–∞
        raise HTTPException(status_code=500, detail={"reason": "order_placement_failed", "details": order})

    # –®–∞–≥ 5: –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
    # `prob` –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ -1, —á—Ç–æ–±—ã –æ–±–æ–∑–Ω–∞—á–∏—Ç—å, —á—Ç–æ —Ñ–∏–ª—å—Ç—Ä –±—ã–ª –æ—Ç–∫–ª—é—á–µ–Ω
    return {"accepted": True, "qty": qty, "prob": -1, "order": order}

# --- Utility Endpoints ---
@app.get("/ping")
async def ping():
    return {"status": "ok", "timestamp": time.time()}

@app.get("/open_positions", response_model=Dict[str, Any])
async def get_open_positions():
    try:
        return await bybit_client.fetch_open_positions()
    except Exception as e:
        raise HTTPException(status_code=500, detail={'error': 'bybit-fetch_failed', 'details': str(e)})

üîπ File: risk_controls.py
----------------------------------------------
import sqlite3
import os
from datetime import date
from functools import wraps
from fastapi import HTTPException

DATABASE_FILE = os.getenv("TRADE_DB", "trades.sqlite")
INITIAL_EQUITY = 1000.0

def get_db_connection():
    # This now uses the (potentially monkeypatched) module-level constant
    conn = sqlite3.connect(DATABASE_FILE)
    conn.row_factory = sqlite3.Row
    return conn

def initialize_pnl_table():
    """Creates the daily_pnl table if it doesn't exist."""
    conn = get_db_connection()
    conn.execute('''
        CREATE TABLE IF NOT EXISTS daily_pnl (
            trade_date DATE PRIMARY KEY,
            realised_pnl REAL NOT NULL DEFAULT 0
        )
    ''')
    conn.commit()
    conn.close()

# REMOVED: The top-level call to initialize_pnl_table() was removed.

def check_daily_drawdown(max_loss_pct: float = 0.03):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            today = date.today()
            conn = get_db_connection()
            cursor = conn.cursor()
            
            current_equity = INITIAL_EQUITY
            max_loss_usd = current_equity * max_loss_pct

            cursor.execute("SELECT realised_pnl FROM daily_pnl WHERE trade_date = ?", (today,))
            result = cursor.fetchone()
            conn.close()

            realised_pnl = result['realised_pnl'] if result else 0.0

            if realised_pnl <= -max_loss_usd:
                raise HTTPException(
                    status_code=429,
                    detail=f"Daily loss limit of ${max_loss_usd:.2f} reached. Realised PnL: ${realised_pnl:.2f}. No new trades allowed."
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

def update_pnl(pnl: float):
    """Updates the PnL for the current day."""
    today = date.today()
    conn = get_db_connection()
    conn.execute('''
        INSERT INTO daily_pnl (trade_date, realised_pnl)
        VALUES (?, ?)
        ON CONFLICT(trade_date) DO UPDATE SET
        realised_pnl = realised_pnl + excluded.realised_pnl;
    ''', (today, pnl))
    conn.commit()
    conn.close()

üîπ File: risk_sizer.py
----------------------------------------------
# File: risk_sizer.py
import math

RISK_PER_TRADE_PCT = 0.01

def calculate_position_size(
    entry_price: float,
    stop_loss_price: float,
    equity: float,
    amount_precision_step: float,
    risk_pct: float = RISK_PER_TRADE_PCT
) -> float:
    
    price_diff = abs(entry_price - stop_loss_price)
    if equity <= 0 or price_diff == 0:
        return 0.0
        
    risk_per_trade_usd = equity * risk_pct
    position_size = risk_per_trade_usd / price_diff

    # –ò–ó–ú–ï–ù–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–π –º–µ—Ç–æ–¥ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
    if amount_precision_step == 1:
        # –î–ª—è —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª (–∫–∞–∫ SHIB) –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ —Ü–µ–ª–æ–≥–æ
        return round(position_size)
    else:
        # –î–ª—è –¥—Ä–æ–±–Ω—ã—Ö - –≤—ã—á–∏—Å–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤ –∏–∑ —à–∞–≥–∞
        decimal_places = -int(math.log10(amount_precision_step))
        return round(position_size, decimal_places)

üîπ File: spring_model.py
----------------------------------------------
import pandas as pd
import numpy as np

def bounce_prob(
    bars: pd.DataFrame,
    side: str,
    price: float,
    bb_window: int = 20,
    bb_std_dev: float = 2.0
) -> float:
    """
    Calculates the 'bounce probability' based on a Bollinger Band mean-reversion model.

    Args:
        bars: DataFrame with historical data, must contain a 'close' column.
        side: The trade side, either 'long' or 'short'.
        price: The current price to evaluate.
        bb_window: The moving average window for Bollinger Bands.
        bb_std_dev: The standard deviation multiplier for Bollinger Bands.

    Returns:
        A probability score [0, 1] indicating the likelihood of a bounce.
    """
    if side not in ['long', 'short']:
        raise ValueError("Side must be either 'long' or 'short'.")

    if len(bars) < bb_window:
        # Not enough data to calculate BBs, no basis for a bounce.
        return 0.0

    # Calculate Bollinger Bands from the historical bars
    closes = bars['close']
    mu = closes.rolling(window=bb_window).mean().iloc[-1]
    sigma = closes.rolling(window=bb_window).std().iloc[-1]

    # Handle case of zero volatility to prevent division by zero
    if sigma == 0:
        return 0.0

    lower_bb = mu - bb_std_dev * sigma
    upper_bb = mu + bb_std_dev * sigma
    p_raw = 0.0

    if side == "long":
        # Probability increases as price drops further below the lower band.
        if price < lower_bb:
            p_raw = (lower_bb - price) / (bb_std_dev * sigma)
    else:  # side == "short"
        # Probability increases as price rises further above the upper band.
        if price > upper_bb:
            p_raw = (price - upper_bb) / (bb_std_dev * sigma)
    
    # Clip the result to be within the valid probability range [0, 1]
    return float(np.clip(p_raw, 0, 1))

üîπ File: tests/__init__.py
----------------------------------------------
# This file is intentionally left empty.
# It marks the 'tests' directory as a Python package.

üîπ File: tests/conftest.py
----------------------------------------------
# File: tests/conftest.py
import pytest
from unittest.mock import AsyncMock, MagicMock

@pytest.fixture
def mock_bybit_client_main(monkeypatch):
    mock_client = AsyncMock()
    mock_client.get_usdt_balance.return_value = 1000.0
    mock_client.create_market_order_with_sl.return_value = {"id": "12345"}
    
    # –ò–ó–ú–ï–ù–ï–ù–û: get_market_precision —Ç–µ–ø–µ—Ä—å —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –º–æ–∫
    mock_client.get_market_precision = MagicMock(
        return_value={"amount": 0.001, "price": 0.01}
    )
    
    mock_client.fetch_open_positions.return_value = {
        'BTCUSDT': {'symbol': 'BTCUSDT', 'contracts': 1.0}
    }
    
    monkeypatch.setattr('main.bybit_client', mock_client)
    
    return mock_client

üîπ File: tests/test_api_execute.py
----------------------------------------------
import pytest
from fastapi.testclient import TestClient
import os

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º app, –º–æ–∫–∏ –±—É–¥—É—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω—ã —á–µ—Ä–µ–∑ conftest
from main import app
client = TestClient(app)

# –≠—Ç–∞ —Ñ–∏–∫—Å—Ç—É—Ä–∞ —Ç–µ–ø–µ—Ä—å —Ç–æ–ª—å–∫–æ –º–æ–∫–∏—Ä—É–µ—Ç –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
@pytest.fixture(autouse=True)
def setup_common_mocks(mocker):
    """–û–±—â–∏–µ –º–æ–∫–∏ –¥–ª—è –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ –≤ —ç—Ç–æ–º —Ñ–∞–π–ª–µ."""
    mocker.patch('main.log_signal')
    mocker.patch('main.log_event')
    yield

def test_execute_trade_calls_all_methods_correctly(mock_bybit_client_main):
    """
    –¢–µ—Å—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ —ç–Ω–¥–ø–æ–∏–Ω—Ç /execute –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –≤—ã–∑—ã–≤–∞–µ—Ç –≤—Å—é —Ü–µ–ø–æ—á–∫—É –º–µ—Ç–æ–¥–æ–≤:
    1. get_market_precision
    2. get_usdt_balance
    3. set_margin_mode
    4. set_leverage
    5. create_market_order_with_sl
    """
    signal = {"symbol": "BTCUSDT", "side": "long", "entry": 53000, "sl": 52500, "tp": 54000}
    
    # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫–∏ –≤—ã–∑–æ–≤–æ–≤ –º–æ–∫–∞ –ø–µ—Ä–µ–¥ —Ç–µ—Å—Ç–æ–º
    mock_bybit_client_main.reset_mock()
    
    response = client.post("/execute", json=signal)
    
    # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–≤–µ—Ç —É—Å–ø–µ—à–Ω—ã–π
    assert response.status_code == 200, response.json()
    data = response.json()
    assert data["accepted"] is True
    assert data["order"]["id"] == "12345"

    # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –Ω—É–∂–Ω—ã–µ –º–µ—Ç–æ–¥—ã wrapper'–∞ –±—ã–ª–∏ –≤—ã–∑–≤–∞–Ω—ã, –∏ –∏–º–µ–Ω–Ω–æ –≤ —ç—Ç–æ–º –ø–æ—Ä—è–¥–∫–µ
    call_order = [call[0] for call in mock_bybit_client_main.method_calls]
    expected_order = [
        'get_market_precision',
        'get_usdt_balance',
        'set_margin_mode',
        'set_leverage',
        'create_market_order_with_sl'
    ]
    assert call_order == expected_order

    # 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∫–ª—é—á–µ–≤—ã—Ö –≤—ã–∑–æ–≤–æ–≤
    mock_bybit_client_main.get_market_precision.assert_called_once_with("BTC/USDT:USDT")
    mock_bybit_client_main.set_margin_mode.assert_called_once_with("BTC/USDT:USDT", "isolated")
    mock_bybit_client_main.set_leverage.assert_called_once_with("BTC/USDT:USDT", 10)
    mock_bybit_client_main.create_market_order_with_sl.assert_called_once()

üîπ File: tests/test_api_utils.py
----------------------------------------------
# File: tests/test_api_utils.py
import pytest
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_ping():
    response = client.get("/ping")
    assert response.status_code == 200
    assert response.json()["status"] == "ok"

def test_open_positions_returns_dict(mock_bybit_client_main): # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å—Ç—É—Ä—É
    response = client.get('/open_positions')
    assert response.status_code == 200
    data = response.json()
    assert "BTCUSDT" in data
    assert data['BTCUSDT']['contracts'] == 1.0

üîπ File: tests/test_backtest_runner.py
----------------------------------------------
import pytest
import pandas as pd
import numpy as np
from backtest_runner import run_backtest, calculate_metrics

def test_backtest_run(monkeypatch): # <-- ADDED monkeypatch
    # Create synthetic data with some volatility to prevent sigma=0
    prices = pd.DataFrame({
        'ts': range(100, 200),
        'close': list(np.linspace(101, 100, 50)) + list(np.linspace(91, 90, 50)),
        'low': list(np.linspace(100, 99, 50)) + list(np.linspace(86, 85, 50)),
        'high': list(np.linspace(102, 101, 50)) + list(np.linspace(96, 95, 50))
    })
    signals = pd.DataFrame({
        'ts': [150],
        'side': ['long'],
        'entry': [90],
        'sl': [88]
    })
    
    # Use monkeypatch to correctly override the function in the target module
    monkeypatch.setattr("backtest_runner.bounce_prob", lambda *args, **kwargs: 1.0)
    
    equity_curve, trades = run_backtest(prices, signals, bb_window=20, bb_std_dev=2.0)
    
    assert len(trades) > 0
    assert equity_curve[-1] != 1000.0

def test_metrics_calculation():
    equity_curve = [1000, 1010, 1005, 1020, 1015]
    total_r, max_dd, sharpe = calculate_metrics(equity_curve, num_days=1)
    
    assert total_r == pytest.approx(0.015)
    # The calculated value is -0.004950495...
    assert max_dd == pytest.approx(-0.00495, abs=1e-5)
    assert sharpe is not None

üîπ File: tests/test_bybit_wrapper.py
----------------------------------------------
import pytest
from unittest.mock import AsyncMock, MagicMock
import ccxt.async_support as ccxt
from bybit_wrapper import AsyncBybitWrapper

@pytest.fixture
def mock_exchange():
    """–§–∏–∫—Å—Ç—É—Ä–∞, —Å–æ–∑–¥–∞—é—â–∞—è –º–æ–∫-–æ–±—ä–µ–∫—Ç –¥–ª—è ccxt.exchange."""
    exchange = AsyncMock()
    exchange.load_markets.return_value = None
    exchange.set_sandbox_mode.return_value = None
    exchange.fetch_balance.return_value = {
        'USDT': {'free': 1000.0, 'used': 0.0, 'total': 1000.0}
    }
    exchange.create_order.return_value = {'id': '12345', 'status': 'open'}
    exchange.market.return_value = {
        'precision': {'amount': 3, 'price': 2}
    }
    return exchange


@pytest.mark.asyncio
async def test_init_and_get_balance(mock_exchange, mocker):
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç —É—Å–ø–µ—à–Ω—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞."""
    # –ü–æ–¥–º–µ–Ω—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–π ccxt.bybit –Ω–∞ –Ω–∞—à –º–æ–∫
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    
    # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä —Å —Ñ–∏–∫—Ç–∏–≤–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏
    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    balance = await wrapper.get_usdt_balance()
    await wrapper.close()

    assert balance == 1000.0
    mock_exchange.load_markets.assert_called_once()
    mock_exchange.fetch_balance.assert_called_once()


@pytest.mark.asyncio
async def test_create_order_success(mock_exchange, mocker):
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç —É—Å–ø–µ—à–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞."""
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    mock_log = mocker.patch('bybit_wrapper.log_trade_execution')
    
    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    result = await wrapper.create_market_order_with_sl('BTC/USDT:USDT', 'buy', 0.01, 59000.0)
    await wrapper.close()

    assert result['id'] == '12345'
    mock_log.assert_called_once()


@pytest.mark.asyncio
async def test_create_order_insufficient_funds(mock_exchange, mocker):
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–∫–∏ –Ω–µ—Ö–≤–∞—Ç–∫–∏ —Å—Ä–µ–¥—Å—Ç–≤."""
    error_message = "bybit-insufficient-balance-for-order-cost"
    mock_exchange.create_order.side_effect = ccxt.InsufficientFunds(error_message)
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    mock_log = mocker.patch('bybit_wrapper.log_trade_execution')

    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    result = await wrapper.create_market_order_with_sl('BTC/USDT:USDT', 'buy', 1.0, 59000.0)
    await wrapper.close()

    assert 'error' in result
    assert error_message in result['error']
    mock_log.assert_called_once()

üîπ File: tests/test_risk_controls.py
----------------------------------------------
import pytest
import sqlite3
import os
import numpy as np
from datetime import date
from fastapi import HTTPException

# Import the module itself to allow monkeypatching
import risk_controls
# Import the functions we need to call
from risk_controls import check_daily_drawdown, update_pnl, get_db_connection

TEST_DB = "test_trades_isolated.sqlite"

@pytest.fixture(autouse=True)
def setup_teardown_db(monkeypatch):
    """
    This fixture is now robust and guarantees test isolation.
    """
    # 1. Use monkeypatch to temporarily change the DATABASE_FILE constant
    #    within the risk_controls module for the duration of one test.
    monkeypatch.setattr(risk_controls, "DATABASE_FILE", TEST_DB)

    # 2. Clean up any previous test database file before the test starts.
    if os.path.exists(TEST_DB):
        os.remove(TEST_DB)
    
    # 3. Initialize a fresh table for this specific test.
    risk_controls.initialize_pnl_table()
    
    yield  # Run the test

    # 4. Clean up the database file after the test is done.
    if os.path.exists(TEST_DB):
        os.remove(TEST_DB)


# A dummy async function to be decorated
@check_daily_drawdown(max_loss_pct=0.03)
async def dummy_trade_route():
    return {"status": "trade allowed"}

@pytest.mark.asyncio
async def test_dd_within_limit():
    update_pnl(-10.0) # Loss is < 3% of 1000
    response = await dummy_trade_route()
    assert response == {"status": "trade allowed"}

@pytest.mark.asyncio
async def test_dd_at_limit():
    update_pnl(-30.0)
    with pytest.raises(HTTPException) as excinfo:
        await dummy_trade_route()
    assert excinfo.value.status_code == 429

@pytest.mark.asyncio
async def test_dd_exceeds_limit():
    update_pnl(-35.0)
    with pytest.raises(HTTPException) as excinfo:
        await dummy_trade_route()
    assert excinfo.value.status_code == 429
    # This assertion will now pass because the PnL is isolated.
    assert "-35.00" in excinfo.value.detail

@pytest.mark.asyncio
async def test_no_pnl_for_today():
    # PnL starts at 0 for this test, so it is allowed.
    response = await dummy_trade_route()
    assert response == {"status": "trade allowed"}

def test_update_pnl_idempotency():
    update_pnl(10.5)
    update_pnl(-5.5)
    
    conn = get_db_connection()
    pnl = conn.execute("SELECT realised_pnl FROM daily_pnl WHERE trade_date = ?", (date.today(),)).fetchone()['realised_pnl']
    conn.close()
    # This will now correctly be 5.0, not an accumulated value.
    assert np.isclose(pnl, 5.0)

üîπ File: tests/test_risk_sizer.py
----------------------------------------------
# File: tests/test_risk_sizer.py
import pytest
from risk_sizer import calculate_position_size

def test_calculate_position_size_btc():
    # step –¥–ª—è BTC = 0.001
    size = calculate_position_size(60000.0, 59000.0, 1000.0, amount_precision_step=0.001)
    assert size == 0.01

def test_calculate_position_size_altcoin():
    # step –¥–ª—è SOL = 0.01
    size = calculate_position_size(150.0, 145.0, 1000.0, amount_precision_step=0.01)
    assert size == 2.0

def test_calculate_position_size_shibcoin():
    # step –¥–ª—è SHIB = 1 (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ)
    size = calculate_position_size(0.000025, 0.000024, 1000.0, amount_precision_step=1)
    # –ò–ó–ú–ï–ù–ï–ù–û: round(10000000.0) == 10000000
    assert size == 10000000

def test_calculate_position_size_zero_balance():
    size = calculate_position_size(60000.0, 59000.0, 0.0, amount_precision_step=0.001)
    assert size == 0.0

def test_calculate_position_size_zero_price_diff():
    size = calculate_position_size(60000.0, 60000.0, 1000.0, amount_precision_step=0.001)
    assert size == 0.0


üîπ File: tests/test_spring_model.py
----------------------------------------------
import pytest
import pandas as pd
import numpy as np
from spring_model import bounce_prob

@pytest.fixture
def synthetic_bars():
    # Synthetic data where mu=100, sigma=5
    # Lower BB = 100 - 2*5 = 90
    # Upper BB = 100 + 2*5 = 110
    np.random.seed(42)
    data = np.concatenate([np.random.normal(100, 5, 19), [100]])
    return pd.DataFrame({'close': data})

def test_long_bounce_strong(synthetic_bars):
    # Price is far below the lower BB, expecting high probability
    prob = bounce_prob(synthetic_bars, 'long', price=80, bb_std_dev=2.0)
    assert prob > 0.5
    assert prob <= 1.0

def test_long_bounce_zero(synthetic_bars):
    # Price is inside the bands, expecting zero probability
    prob = bounce_prob(synthetic_bars, 'long', price=95, bb_std_dev=2.0)
    assert prob == 0.0

def test_short_bounce_strong(synthetic_bars):
    # Price is far above the upper BB, expecting high probability
    prob = bounce_prob(synthetic_bars, 'short', price=120, bb_std_dev=2.0)
    assert prob > 0.5
    assert prob <= 1.0

def test_short_bounce_zero(synthetic_bars):
    # Price is inside the bands, expecting zero probability
    prob = bounce_prob(synthetic_bars, 'short', price=105, bb_std_dev=2.0)
    assert prob == 0.0

def test_edge_case_not_enough_data():
    bars = pd.DataFrame({'close': [100, 101]})
    prob = bounce_prob(bars, 'long', price=95, bb_window=20)
    assert prob == 0.0

def test_edge_case_zero_volatility():
    bars = pd.DataFrame({'close': [100] * 20})
    prob = bounce_prob(bars, 'long', price=95, bb_window=20)
    assert prob == 0.0

def test_invalid_side(synthetic_bars):
    with pytest.raises(ValueError):
        bounce_prob(synthetic_bars, 'sideways', price=100)

üîπ File: tests/test_trade_logger.py
----------------------------------------------
# File: tests/test_trade_logger.py (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø)
import pytest
import os
from datetime import datetime
import trade_logger

TEST_DB = "test_log_final.sqlite"

@pytest.fixture(autouse=True)
def setup_teardown_db(monkeypatch):
    monkeypatch.setattr(trade_logger, "DATABASE_FILE", TEST_DB)
    monkeypatch.setattr(trade_logger, "_db_instance", None)
    
    if os.path.exists(TEST_DB):
        os.remove(TEST_DB)
    yield
    if os.path.exists(TEST_DB):
        os.remove(TEST_DB)

def test_log_signal():
    signal_data = {
        'pair': 'BTC/USDT:USDT',
        'side': 'long',
    }
    trade_logger.log_signal(signal_data)
    db = trade_logger.get_db()
    log_entry = list(db["trade_log"].rows)[0]
    assert log_entry["event_type"] == "SIGNAL_RECEIVED"
    assert log_entry["pair"] == "BTC/USDT:USDT"

def test_log_successful_execution():
    order_data = {
        'id': '123456789', 'cid': 'my_client_id_001', 'symbol': 'BTC/USDT:USDT',
        'side': 'buy', 'amount': 0.001, 'price': 60100.0,
        'status': 'open', 'error': None
    }
    trade_logger.log_trade_execution(order_data)

    db = trade_logger.get_db()
    log_entry = list(db["trade_log"].rows)[0]

    assert log_entry["event_type"] == "ORDER_PLACED"
    # –ò–ó–ú–ï–ù–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á 'id', –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏—Ö–æ–¥–∏—Ç –æ—Ç CCXT –∏ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –≤ –ª–æ–≥
    assert log_entry["id"] == '123456789' 
    assert log_entry["error"] is None

üîπ File: trade_logger.py
----------------------------------------------
import sqlite_utils
import os
from datetime import datetime, timezone

DATABASE_FILE = os.getenv("TRADE_DB", "trades.sqlite")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
_db_instance = None

def get_db():
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö (—Å–∏–Ω–≥–ª—Ç–æ–Ω).
    –≠—Ç–æ –ø–æ–≤—ã—à–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –≤ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π —Å—Ä–µ–¥–µ.
    """
    global _db_instance
    if _db_instance is None:
        _db_instance = sqlite_utils.Database(DATABASE_FILE)
    return _db_instance

def log_event(event_type: str, payload: dict):
    """
    –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Å–æ–±—ã—Ç–∏–µ –≤ —Ç–∞–±–ª–∏—Ü—É 'trade_log'.
    """
    db = get_db()
    # pk="id" —É–±—Ä–∞–Ω. sqlite-utils –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π rowid.
    log_table = db.table("trade_log")
    
    record = {
        "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "event_type": event_type,
    }
    record.update(payload)
    
    log_table.insert(record, alter=True)
    print(f"[LOG] Event '{event_type}': {payload}")

def log_signal(signal: dict):
    """–õ–æ–≥–∏—Ä—É–µ—Ç –≤—Ö–æ–¥—è—â–∏–π —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª."""
    log_event("SIGNAL_RECEIVED", payload=signal)

def log_trade_execution(order_result: dict):
    """–õ–æ–≥–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –±–∏—Ä–∂–µ."""
    payload = {
        "client_order_id": order_result.get('cid'),
        "exchange_order_id": order_result.get('id'),
        "symbol": order_result.get('symbol'),
        "side": order_result.get('side'),
        "amount": order_result.get('amount'),
        "price": order_result.get('price'),
        "status": order_result.get('status'),
        "error": order_result.get('error')
    }
    event_type = "ORDER_FAILED" if payload['error'] else "ORDER_PLACED"
    log_event(event_type, payload=payload)

def log_trade_execution(order_result: dict):
    """–õ–æ–≥–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –±–∏—Ä–∂–µ."""
    # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é, —á—Ç–æ–±—ã –Ω–µ –∏–∑–º–µ–Ω—è—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç –æ—Ç ccxt
    payload = order_result.copy()
    event_type = "ORDER_FAILED" if payload.get('error') else "ORDER_PLACED"
    log_event(event_type, payload=payload)

def log_signal(signal: dict):
    """–õ–æ–≥–∏—Ä—É–µ—Ç –≤—Ö–æ–¥—è—â–∏–π —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª."""
    log_event("SIGNAL_RECEIVED", payload=signal)