ğŸ§  Python Project Dump for LLM â€” spring-bot
ğŸ“… Date: Wed Jul  9 18:11:00 +05 2025
ğŸ“‚ Path: /Users/rshagiev/PycharmProjects/spring-bot
==============================================


ğŸ“ Project Structure (tree -L 3):
----------------------------------------------
.
â”œâ”€â”€ backtest_runner.py
â”œâ”€â”€ bybit_wrapper.py
â”œâ”€â”€ check_keys.py
â”œâ”€â”€ dashboard.py
â”œâ”€â”€ db_setup.py
â”œâ”€â”€ db_utils.py
â”œâ”€â”€ dump_python_files.sh
â”œâ”€â”€ main.py
â”œâ”€â”€ models.py
â”œâ”€â”€ position_manager.py
â”œâ”€â”€ project_dump.txt
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ risk_controls.py
â”œâ”€â”€ risk_sizer.py
â”œâ”€â”€ signal_parser.py
â”œâ”€â”€ spring_model.py
â”œâ”€â”€ tests
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ conftest.py
â”‚Â Â  â”œâ”€â”€ test_api_process_signal.py
â”‚Â Â  â”œâ”€â”€ test_backtest_runner.py
â”‚Â Â  â”œâ”€â”€ test_bybit_wrapper.py
â”‚Â Â  â”œâ”€â”€ test_position_manager.py
â”‚Â Â  â”œâ”€â”€ test_risk_controls.py
â”‚Â Â  â”œâ”€â”€ test_risk_sizer.py
â”‚Â Â  â”œâ”€â”€ test_signal_parser.py
â”‚Â Â  â”œâ”€â”€ test_spring_model.py
â”‚Â Â  â””â”€â”€ test_trade_logger.py
â”œâ”€â”€ trade_logger.py
â”œâ”€â”€ trades.sqlite
â”œâ”€â”€ trades.sqlite-shm
â””â”€â”€ trades.sqlite-wal

2 directories, 32 files


ğŸ“¦ requirements.txt:
----------------------------------------------
# Core Logic & Data
pandas
numpy

# API & Web Services
fastapi
uvicorn
aiofiles

# Exchange Integration
ccxt==4.*

# Database
sqlite-utils==3.*

# Testing
pytest
pytest-asyncio
pytest-mock
httpx 

# UI & Dashboard
streamlit
streamlit-autorefresh
python-dotenv

ğŸ“ Python Files:
==============================================


ğŸ”¹ File: backtest_runner.py
----------------------------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from itertools import product
from spring_model import bounce_prob

# --- Constants ---
INITIAL_EQUITY = 1000.0
RISK_PER_TRADE_PCT = 0.01
FIXED_RR_RATIO = 1.5
PROB_THRESHOLD = 0.5

def run_backtest(price_df, signals_df, bb_window, bb_std_dev):
    equity = INITIAL_EQUITY
    equity_curve = [INITIAL_EQUITY]
    trades = []

    for _, signal in signals_df.iterrows():
        # Find the price data available right before the signal
        bars = price_df[price_df['ts'] < signal['ts']].tail(bb_window)
        if len(bars) < bb_window:
            continue

        # 1. Filter signal through the spring model
        prob = bounce_prob(bars, signal['side'], signal['entry'], bb_window, bb_std_dev)
        if prob < PROB_THRESHOLD:
            continue

        # 2. Size the trade
        risk_per_trade_usd = equity * RISK_PER_TRADE_PCT
        stop_loss_dist = abs(signal['entry'] - signal['sl'])
        if stop_loss_dist == 0: continue
        position_size = risk_per_trade_usd / stop_loss_dist

        # 3. Determine TP based on fixed R:R
        take_profit_dist = stop_loss_dist * FIXED_RR_RATIO
        if signal['side'] == 'long':
            tp_price = signal['entry'] + take_profit_dist
            sl_price = signal['sl']
        else:
            tp_price = signal['entry'] - take_profit_dist
            sl_price = signal['sl']

        # 4. Simulate trade execution
        trade_data = price_df[price_df['ts'] >= signal['ts']]
        pnl = 0
        outcome = 'No fill'
        for _, row in trade_data.iterrows():
            if signal['side'] == 'long':
                if row['high'] >= tp_price:
                    pnl = (tp_price - signal['entry']) * position_size
                    outcome = 'TP'
                    break
                if row['low'] <= sl_price:
                    pnl = (sl_price - signal['entry']) * position_size
                    outcome = 'SL'
                    break
            else: # short
                if row['low'] <= tp_price:
                    pnl = (signal['entry'] - tp_price) * position_size
                    outcome = 'TP'
                    break
                if row['high'] >= sl_price:
                    pnl = (signal['entry'] - sl_price) * position_size
                    outcome = 'SL'
                    break

        if outcome in ['TP', 'SL']:
            equity += pnl
            equity_curve.append(equity)
            trades.append({'pnl': pnl, 'outcome': outcome})
    
    return equity_curve, trades

def calculate_metrics(equity_curve, num_days):
    returns = pd.Series(equity_curve).pct_change().dropna()
    total_return = (equity_curve[-1] / INITIAL_EQUITY) - 1
    
    # Max Drawdown
    rolling_max = pd.Series(equity_curve).cummax()
    drawdown = (pd.Series(equity_curve) - rolling_max) / rolling_max
    max_drawdown = drawdown.min()
    
    # Sharpe Ratio (annualized)
    daily_returns = returns[returns != 0]
    if len(daily_returns) > 1 and daily_returns.std() != 0:
        # NOTE: This is an approximate annualization, assuming trades are somewhat evenly distributed.
        # It's suitable for comparing parameters but is not a perfectly rigorous Sharpe calculation.
        sharpe_ratio = (daily_returns.mean() / daily_returns.std()) * np.sqrt(365 * 24 * 60 / (num_days * 24 * 60 / len(daily_returns)) )
    else:
        sharpe_ratio = 0

    return total_return, max_drawdown, sharpe_ratio

if __name__ == '__main__':
    # 1. Load data
    try:
        price_df = pd.read_csv('btc_1m.csv', names=['ts', 'open', 'high', 'low', 'close', 'volume'])
        signals_df = pd.read_csv('signals.csv') # ts, side, entry, sl, tp
    except FileNotFoundError as e:
        print(f"Error: {e}. Make sure 'btc_1m.csv' (no header) and 'signals.csv' are present.")
        exit()

    # Ensure timestamps are numeric for comparison (OS-agnostic method)
    price_df['ts'] = pd.to_datetime(price_df['ts']).view('int64') // 10**9
    signals_df['ts'] = pd.to_datetime(signals_df['ts']).view('int64') // 10**9
    num_days = (price_df['ts'].max() - price_df['ts'].min()) / (60 * 60 * 24)

    # 5. Parameter Grid Search
    bb_windows = [10, 20, 30]
    bb_multipliers = [1.5, 2.0, 2.5]
    results = []

    print("Running backtest grid search...")
    for window, mult in product(bb_windows, bb_multipliers):
        equity_curve, trades = run_backtest(price_df, signals_df, window, mult)
        if len(equity_curve) > 1:
            total_r, max_dd, sharpe = calculate_metrics(equity_curve, num_days)
            results.append(((window, mult), total_r, max_dd, sharpe, len(trades)))
    
    # Print results
    print("\n--- Backtest Results ---")
    print(f"{'Params (win, std)':<20} | {'Total Return':>15} | {'Max Drawdown':>15} | {'Sharpe Ratio':>15} | {'Num Trades':>12}")
    print('-'*85)
    sorted_results = sorted(results, key=lambda x: x[3], reverse=True) # Sort by Sharpe
    for params, total_r, max_dd, sharpe, num_trades in sorted_results:
        print(f"{str(params):<20} | {total_r:>14.2%} | {max_dd:>14.2%} | {sharpe:>15.2f} | {num_trades:>12}")

    # Plot the best result
    if sorted_results:
        best_params = sorted_results[0][0]
        print(f"\nPlotting equity curve for best params: {best_params}")
        best_equity_curve, _ = run_backtest(price_df, signals_df, best_params[0], best_params[1])
        plt.figure(figsize=(12, 6))
        plt.plot(best_equity_curve)
        plt.title(f'Equity Curve - Best Params: {best_params} (Sharpe: {sorted_results[0][3]:.2f})')
        plt.xlabel('Trade Number')
        plt.ylabel('Equity (USDT)')
        plt.grid(True)
        plt.savefig('equity_curve.png')
        print("Saved equity curve to equity_curve.png")

ğŸ”¹ File: bybit_wrapper.py
----------------------------------------------
import ccxt.async_support as ccxt
import os
from trade_logger import log_trade_execution, log_event

class AsyncBybitWrapper:
    def __init__(self, api_key: str, secret_key: str, testnet: bool = True):
        if not api_key or not secret_key:
            raise ValueError("API key and secret must be provided.")
        
        self.testnet = testnet
        self.exchange = ccxt.bybit({
            'apiKey': api_key,
            'secret': secret_key,
            'options': {'defaultType': 'swap'},
        })
        if self.testnet:
            self.exchange.set_sandbox_mode(True)

    async def init(self):
        try:
            await self.exchange.load_markets()
            print(f"Successfully connected to Bybit. Sandbox mode: {self.testnet}")
        except Exception as e:
            await self.close()
            raise

    async def close(self):
        if self.exchange:
            await self.exchange.close()

    # --- Ğ”ĞĞ‘ĞĞ’Ğ¬Ğ¢Ğ• Ğ­Ğ¢Ğ˜ Ğ”Ğ’Ğ ĞœĞ•Ğ¢ĞĞ”Ğ ---
    async def set_leverage(self, symbol: str, leverage: int):
        """Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ ĞºÑ€ĞµĞ´Ğ¸Ñ‚Ğ½Ğ¾Ğµ Ğ¿Ğ»ĞµÑ‡Ğ¾ Ğ´Ğ»Ñ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°."""
        try:
            await self.exchange.set_leverage(leverage, symbol)
            log_event("LEVERAGE_SET", {"symbol": symbol, "leverage": leverage})
        except Exception as e:
            log_event("LEVERAGE_ERROR", {"symbol": symbol, "error": str(e)})
            # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ½Ğµ ĞºĞ¸Ğ´Ğ°Ñ‚ÑŒ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ, ĞµÑĞ»Ğ¸ Ğ±Ğ¸Ñ€Ğ¶Ğ° Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸ Ñ‚Ğ°Ğº
            print(f"Warning: Failed to set leverage for {symbol}: {e}")

    async def set_margin_mode(self, symbol: str, margin_mode: str):
        """Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ¼Ğ°Ñ€Ğ¶Ğ¸ ('cross' Ğ¸Ğ»Ğ¸ 'isolated')."""
        try:
            unified_symbol = symbol.split(':')[0]
            await self.exchange.set_margin_mode(margin_mode, unified_symbol, params={'settleCoin': 'USDT'})
            log_event("MARGIN_MODE_SET", {"symbol": symbol, "mode": margin_mode})
        except Exception as e:
            log_event("MARGIN_MODE_ERROR", {"symbol": symbol, "error": str(e)})
            print(f"Warning: Failed to set margin mode for {symbol}: {e}")
    # ------------------------------------

    def get_market_precision(self, symbol: str) -> dict:
        try:
            market = self.exchange.market(symbol)
            return {'price': market['precision']['price'], 'amount': market['precision']['amount']}
        except (ccxt.BadSymbol, KeyError):
            return None

    async def get_usdt_balance(self) -> float:
        try:
            balance = await self.exchange.fetch_balance()
            return float(balance.get('USDT', {}).get('total', 0.0))
        except Exception as e:
            return 0.0

    async def fetch_open_positions(self) -> dict:
        try:
            positions = await self.exchange.fetch_positions()
            return {p['info']['symbol']: p for p in positions if float(p.get('contracts', 0)) != 0}
        except Exception:
            return {}
    
    # --- Ğ”ĞĞ‘ĞĞ’Ğ¬Ğ¢Ğ• Ğ­Ğ¢ĞĞ¢ ĞœĞ•Ğ¢ĞĞ” ---
    async def fetch_ticker_price(self, symbol: str) -> float:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ Ñ†ĞµĞ½Ñƒ Ğ´Ğ»Ñ Ñ‚Ğ¸ĞºĞµÑ€Ğ°."""
        try:
            ticker = await self.exchange.fetch_ticker(symbol)
            return float(ticker['last'])
        except Exception as e:
            print(f"Error fetching ticker for {symbol}: {e}")
            return 0.0
    # ---------------------------

    async def create_market_order_with_sl(self, symbol: str, side: str, amount: float, stop_loss_price: float) -> dict:
        params = {'stopLoss': stop_loss_price}
        try:
            order = await self.exchange.create_order(symbol, 'market', side, amount, params=params)
            log_trade_execution(order)
            return order
        except Exception as e:
            error_payload = {'symbol': symbol, 'error': str(e)}
            log_trade_execution(error_payload)
            return error_payload
    
    async def create_order(self, symbol: str, type: str, side: str, amount: float, price: float = None, params={}) -> dict:
        """Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²."""
        try:
            order = await self.exchange.create_order(symbol, type, side, amount, price, params)
            log_trade_execution(order)
            return order
        except Exception as e:
            error_payload = {'symbol': symbol, 'type': type, 'side': side, 'error': str(e)}
            log_trade_execution(error_payload)
            raise e
        
    async def create_limit_order(self, symbol: str, side: str, amount: float, price: float, params={}) -> dict:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ½Ñ‹Ğ¹ Ğ¾Ñ€Ğ´ĞµÑ€."""
        try:
            order = await self.exchange.create_limit_order(symbol, side, amount, price, params=params)
            log_trade_execution(order)
            return order
        except Exception as e:
            error_payload = {'symbol': symbol, 'side': side, 'amount': amount, 'price': price, 'error': str(e)}
            log_trade_execution(error_payload)
            raise  # ĞŸĞµÑ€ĞµĞ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ğ¹ ĞºĞ¾Ğ´ Ğ¼Ğ¾Ğ³ ĞµĞ³Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ

    async def edit_order(self, order_id: str, symbol: str, new_price: float) -> dict:
        """Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ñ†ĞµĞ½Ñƒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ¾Ñ€Ğ´ĞµÑ€Ğ° (Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ Ğ´Ğ»Ñ SL/TP)."""
        try:
            order = await self.exchange.edit_order(order_id, symbol, params={'triggerPrice': new_price})
            log_event("ORDER_EDITED", order)
            return order
        except Exception as e:
            error_payload = {'order_id': order_id, 'symbol': symbol, 'new_price': new_price, 'error': str(e)}
            log_event("ORDER_EDIT_FAILED", error_payload)
            raise
    
    async def cancel_order(self, order_id: str, symbol: str) -> dict:
        """ĞÑ‚Ğ¼ĞµĞ½ÑĞµÑ‚ Ğ¾Ñ€Ğ´ĞµÑ€."""
        try:
            response = await self.exchange.cancel_order(order_id, symbol)
            log_event("ORDER_CANCELLED", response)
            return response
        except Exception as e:
            error_payload = {'order_id': order_id, 'symbol': symbol, 'error': str(e)}
            log_event("ORDER_CANCEL_FAILED", error_payload)
            # ĞĞµ Ğ¿ĞµÑ€ĞµĞ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ, Ñ‚.Ğº. Ğ¾Ñ€Ğ´ĞµÑ€ Ğ¼Ğ¾Ğ³ ÑƒĞ¶Ğµ Ğ±Ñ‹Ñ‚ÑŒ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½/Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½
            return error_payload

    async def fetch_my_trades(self, symbol: str, limit: int = 20) -> list:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ñ… ÑĞ´ĞµĞ»Ğ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
        if self.exchange.has['fetchMyTrades']:
            return await self.exchange.fetch_my_trades(symbol, limit=limit)
        return []

ğŸ”¹ File: check_keys.py
----------------------------------------------
# File: check_keys.py (Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯ Ğ¡ Ğ¥ĞĞ Ğ”ĞšĞĞ”ĞĞœ)
import os
import asyncio
import ccxt.async_support as ccxt
# from dotenv import load_dotenv # Ğ‘Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾

async def main():
    # load_dotenv() # Ğ‘Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾
    
    # --- Ğ’Ğ Ğ•ĞœĞ•ĞĞĞ Ğ’Ğ¡Ğ¢ĞĞ’Ğ›Ğ¯Ğ•Ğœ ĞšĞ›Ğ®Ğ§Ğ˜ ĞŸĞ Ğ¯ĞœĞ Ğ¡Ğ®Ğ”Ğ ---
    api_key = "Xyo4o0isLLDU1vaRlN"
    secret = "L4BnWcl26eeeWYT3keMiKLtnFwmKm0tKQoJp"
    # ---------------------------------------------

    print(f"--- Checking Keys (Hardcoded) ---")
    print(f"API Key used: {api_key}")
    print("-" * 20)

    exchange = ccxt.bybit({
        'apiKey': api_key,
        'secret': secret,
    })
    exchange.set_sandbox_mode(True)

    try:
        print("Attempting to fetch balance...")
        balance = await exchange.fetch_balance()
        print("\nSUCCESS! Connection is working.")
        print(f"Available USDT Balance: {balance.get('USDT', {}).get('free', 0.0)}")
    except ccxt.AuthenticationError as e:
        print(f"\nERROR: Authentication failed. Bybit says: {e}")
        print("This confirms the issue is with the keys themselves or their permissions on Bybit's side.")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
    finally:
        await exchange.close()

if __name__ == "__main__":
    asyncio.run(main())

ğŸ”¹ File: dashboard.py
----------------------------------------------
# file: dashboard.py
import streamlit as st
import pandas as pd
from streamlit_autorefresh import st_autorefresh
from db_utils import get_db_connection
import json

# --- ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ ---
REFRESH_INTERVAL_SECONDS = 10
st.set_page_config(page_title="Trading Bot Dashboard", layout="wide")
st_autorefresh(interval=REFRESH_INTERVAL_SECONDS * 1000, key="dashboard_refresh")

# --- Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ---
@st.cache_data(ttl=REFRESH_INTERVAL_SECONDS)
def load_data():
    conn = get_db_connection()
    active = pd.read_sql_query("SELECT * FROM managed_trades WHERE status != 'CLOSED' ORDER BY created_at DESC", conn)
    history = pd.read_sql_query("SELECT * FROM managed_trades WHERE status = 'CLOSED' ORDER BY updated_at DESC LIMIT 50", conn)
    # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ left join Ğ´Ğ»Ñ Ğ¾Ğ±Ğ¾Ğ³Ğ°Ñ‰ĞµĞ½Ğ¸Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ´ĞµĞ»Ğ¾Ğº Ğ¶Ğ¸Ğ²Ñ‹Ğ¼Ğ¸ Ñ†ĞµĞ½Ğ°Ğ¼Ğ¸
    prices = pd.read_sql_query("SELECT * FROM live_prices", conn)
    if not active.empty and not prices.empty:
        active = pd.merge(active, prices, on='symbol', how='left')
    conn.close()
    return active, history

# --- ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´Ğ° ---
st.title("ğŸ¤– Stateful Trading Bot Dashboard v2.0")
active_df, history_df = load_data()

# --- Ğ‘Ğ»Ğ¾Ğº 1: Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼Ñ‹Ğµ Ğ¡Ğ´ĞµĞ»ĞºĞ¸ ---
st.subheader("ğŸ“Š Managed Trades")
if not active_df.empty:
    active_df['progress'] = active_df['executed_qty'] / active_df['total_qty']
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ğ¼ uPNL (ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ¾)
    if 'mark_price' in active_df.columns:
        active_df['uPNL'] = (active_df['mark_price'] - active_df['avg_entry_price']) * active_df['executed_qty']
        active_df.loc[active_df['side'] == 'short', 'uPNL'] *= -1

    st.dataframe(
        active_df.style.bar(subset=['progress'], align='mid', color=['#d6e8d6', '#e8d6d6']),
        use_container_width=True, hide_index=True
    )
else:
    st.info("No active trades to manage.")

# --- Ğ‘Ğ»Ğ¾Ğº 2: Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¡Ğ´ĞµĞ»Ğ¾Ğº ---
st.subheader("ğŸ“ˆ Trade History")
if not history_df.empty:
    st.dataframe(history_df, use_container_width=True, hide_index=True)
else:
    st.info("Trade history is empty.")

# --- Ğ‘Ğ»Ğ¾Ğº 3: Ğ–ÑƒÑ€Ğ½Ğ°Ğ» Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹ (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾, ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶ĞµĞ½) ---
# ...

ğŸ”¹ File: db_setup.py
----------------------------------------------
# file: db_setup.py
import sqlite3
from db_utils import get_db_connection

def setup_database():
    """
    Creates or updates all necessary tables and indexes in the DB.
    This script is idempotent and safe to run multiple times.
    """
    print("--- Starting Database Setup ---")
    conn = get_db_connection()
    cursor = conn.cursor()

    try:
        # Table 1: Managed Trades (the heart of the system)
        print("1. Creating 'managed_trades' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS managed_trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            instruction_id TEXT NOT NULL,
            symbol TEXT NOT NULL,
            side TEXT NOT NULL CHECK(side IN ('long', 'short')),
            status TEXT NOT NULL CHECK(status IN ('PENDING_ENTRY', 'ACTIVE', 'CLOSING', 'CLOSED')),
            
            entry_range_start REAL NOT NULL,
            entry_range_end REAL NOT NULL,
            initial_tps TEXT NOT NULL,
            
            avg_entry_price REAL,
            total_qty REAL NOT NULL,
            executed_qty REAL NOT NULL DEFAULT 0,
            
            initial_sl_price REAL NOT NULL,
            current_sl_price REAL NOT NULL,
            exchange_sl_order_id TEXT,
            
            -- CORRECTED COLUMN DEFINITION --
            move_sl_to_be_after_tp_index INTEGER, 
            
            remaining_tps TEXT NOT NULL,
            close_reason TEXT,
            realized_pnl REAL,
            
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL
        );
        """)
        print("   ... 'managed_trades' table is ready.")

        # Table 2: Entry Orders
        print("2. Creating 'entry_orders' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS entry_orders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            trade_id INTEGER NOT NULL,
            exchange_order_id TEXT NOT NULL UNIQUE,
            status TEXT NOT NULL,
            FOREIGN KEY (trade_id) REFERENCES managed_trades (id)
        );
        """)
        print("   ... 'entry_orders' table is ready.")

        # Table 3: Live Prices
        print("3. Creating 'live_prices' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS live_prices (
            symbol TEXT PRIMARY KEY,
            mark_price REAL NOT NULL,
            updated_at TEXT NOT NULL
        );
        """)
        print("   ... 'live_prices' table is ready.")

        # Table 4: Daily PnL for Risk Controls
        print("4. Creating 'daily_pnl' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS daily_pnl (
            trade_date DATE PRIMARY KEY,
            realised_pnl REAL NOT NULL DEFAULT 0
        );
        """)
        print("   ... 'daily_pnl' table is ready.")
        
        # Table 5: General Event Log
        print("5. Creating 'trade_log' table...")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS trade_log (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           timestamp_utc TEXT NOT NULL,
           event_type TEXT NOT NULL,
           -- CORRECTED COLUMN DEFINITION (NULLABLE) --
           payload_json TEXT 
        );
        """)
        print("   ... 'trade_log' table is ready.")

        # Indexes for performance
        print("6. Creating indexes for performance...")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_managed_trades_status ON managed_trades(status);")
        # ... other indexes ...
        print("   ... Indexes are ready.")
        
        # Schema versioning
        print("7. Setting up schema version...")
        cursor.execute("CREATE TABLE IF NOT EXISTS db_meta (key TEXT PRIMARY KEY, value TEXT NOT NULL);")
        cursor.execute("INSERT OR IGNORE INTO db_meta (key, value) VALUES ('schema_version', '3');")
        print("   ... Schema version is set.")

        conn.commit()
        print("\n--- Database setup successfully completed! ---")

    except Exception as e:
        print(f"\n--- An error occurred during database setup: {e} ---")
        conn.rollback()
    finally:
        conn.close()

if __name__ == "__main__":
    setup_database()

ğŸ”¹ File: db_utils.py
----------------------------------------------
# file: db_utils.py
import sqlite3
import json
from datetime import datetime, timezone
import os

# ĞŸÑƒÑ‚ÑŒ Ğº Ğ‘Ğ” Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ±ĞµÑ€ĞµÑ‚ÑÑ Ğ¸Ğ· env-Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ´Ğ»Ñ Ğ³Ğ¸Ğ±ĞºĞ¾ÑÑ‚Ğ¸ Ğ¸ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
# Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° Ğ² conftest.py Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ¼ĞµĞ½ÑÑ‚ÑŒ ÑÑ‚Ñƒ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ².
DATABASE_FILE = os.getenv("DATABASE_FILE", "trades.sqlite")

def get_db_connection() -> sqlite3.Connection:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞĞĞ’ĞĞ• ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ SQLite Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ğ¼Ğ¸ Ğ´Ğ»Ñ production.
    """
    # timeout=30 (Ğ² ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…) Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ busy_timeout
    # check_same_thread=False Ğ²Ğ°Ğ¶Ğ½Ğ¾ Ğ´Ğ»Ñ FastAPI, Ğ½Ğ¾ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ°ĞºĞºÑƒÑ€Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸ÑĞ¼Ğ¸.
    conn = sqlite3.connect(DATABASE_FILE, timeout=30, check_same_thread=False)
    # WAL-Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ´Ğ»Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğ¹ ĞºĞ¾Ğ½ĞºÑƒÑ€ĞµĞ½Ñ‚Ğ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹
    conn.execute("PRAGMA journal_mode=WAL;")
    conn.row_factory = sqlite3.Row
    return conn

def create_managed_trade(instruction: dict, total_qty: float) -> int:
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ´ĞµĞ»ĞºĞµ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğµ managed_trades.
    Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑĞ°Ğ¼Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ²Ğ¾Ğ¸Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ñ Ğ‘Ğ”, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾-Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğ¹.
    """
    conn = get_db_connection()
    try:
        now_utc = datetime.now(timezone.utc).isoformat(timespec='microseconds')
        
        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ `with conn:` Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğ° Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸
        with conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO managed_trades (
                    instruction_id, symbol, side, status, entry_range_start, entry_range_end,
                    total_qty, initial_sl_price, current_sl_price, initial_tps, remaining_tps,
                    move_sl_to_be_after_tp_index, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    instruction.get('signal_id', 'unknown'), 
                    instruction.get('symbol', 'BTCUSDT'), 
                    instruction['side'], 
                    'PENDING_ENTRY',
                    instruction['entry_start'], 
                    instruction['entry_end'], 
                    total_qty,
                    instruction['stop_loss'], 
                    instruction['stop_loss'],
                    json.dumps(instruction['take_profits']), 
                    json.dumps(instruction['take_profits']),
                    instruction.get('move_sl_to_be_after_tp_index', 1),
                    now_utc, 
                    now_utc
                )
            )
            trade_id = cursor.lastrowid
    finally:
        # Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
        if conn:
            conn.close()
            
    return trade_id

ğŸ”¹ File: main.py
----------------------------------------------
# file: main.py
import asyncio
import os
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, Depends
from dotenv import load_dotenv
import sqlite3

load_dotenv()

from bybit_wrapper import AsyncBybitWrapper
from risk_sizer import calculate_position_size
from risk_controls import check_daily_drawdown
from trade_logger import log_event
from signal_parser import parse_pentagon_signal
from db_utils import get_db_connection, create_managed_trade 
from position_manager import position_manager_loop, place_entry_grid
from models import TradeInstruction

API_KEY = os.getenv("BYBIT_KEY")
API_SECRET = os.getenv("BYBIT_SECRET")
if not API_KEY or not API_SECRET:
    raise RuntimeError("BYBIT_KEY and BYBIT_SECRET must be set in .env file")

bybit_client = AsyncBybitWrapper(api_key=API_KEY, secret_key=API_SECRET, testnet=True)
background_tasks = set()

@asynccontextmanager
async def lifespan(app: FastAPI):
    await bybit_client.init()
    manager_task = asyncio.create_task(position_manager_loop(bybit_client))
    background_tasks.add(manager_task)
    manager_task.add_done_callback(background_tasks.discard)
    log_event("APP_STARTUP", {"message": "Position manager started."})
    
    yield
    
    log_event("APP_SHUTDOWN", {"message": "Cancelling background tasks."})
    for task in list(background_tasks): # Iterate over a copy
        task.cancel()
    await bybit_client.close()
    log_event("APP_SHUTDOWN_COMPLETE", {"message": "Bybit client closed."})

app = FastAPI(title="Stateful Trading Bot", version="1.0.0", lifespan=lifespan)

def get_db():
    db = get_db_connection()
    try:
        yield db
    finally:
        db.close()

@app.post("/process_signal", status_code=202)
@check_daily_drawdown(max_loss_pct=0.03) 
async def process_signal(raw_text: str, db: sqlite3.Connection = Depends(get_db)): 
    instruction = parse_pentagon_signal(raw_text)
    if not instruction:
        raise HTTPException(status_code=400, detail="Signal parsing failed.")
    
    log_event("INSTRUCTION_PARSED", instruction.model_dump())

    equity = await bybit_client.get_usdt_balance()
    precision = bybit_client.get_market_precision(instruction.symbol)
    if not precision or 'amount' not in precision:
        raise HTTPException(status_code=500, detail="Could not get precision for symbol {instruction.symbol}")

    risk_entry_price = instruction.entry_end if instruction.side == 'short' else instruction.entry_start
    total_qty = calculate_position_size(
        entry_price=risk_entry_price, stop_loss_price=instruction.stop_loss,
        equity=equity, amount_precision_step=precision['amount'],
        risk_pct=instruction.risk_pct
    )
    final_qty = total_qty * instruction.size_fraction
    if final_qty <= 0:
        raise HTTPException(status_code=400, detail="Calculated position size is zero.")

    trade_id = create_managed_trade(instruction.model_dump(), final_qty) 
    log_event("TRADE_CREATED_IN_DB", {"trade_id": trade_id, "qty": final_qty})

    task = asyncio.create_task(
        place_entry_grid(trade_id, final_qty, instruction.model_dump(), bybit_client)
    )
    background_tasks.add(task)
    task.add_done_callback(background_tasks.discard)

    return {"status": "accepted", "trade_id": trade_id}

ğŸ”¹ File: models.py
----------------------------------------------
# file: models.py
from pydantic import BaseModel, Field
from typing import List, Optional

class TradeInstruction(BaseModel):
    """Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ñ, Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ½Ğ°Ñ Ğ¸Ğ· Ğ¿Ğ°Ñ€ÑĞµÑ€Ğ°."""
    signal_id: str
    symbol: str = "BTCUSDT"
    side: str
    entry_start: float
    entry_end: float
    stop_loss: float
    risk_pct: float = Field(..., gt=0, le=0.1)
    size_fraction: float = Field(default=1.0, ge=0.1, le=1.0)
    take_profits: List[float]
    move_sl_to_be_after_tp_index: int = 1

ğŸ”¹ File: position_manager.py
----------------------------------------------
# file: position_manager.py
import asyncio
import json
import numpy as np
import sqlite3
from datetime import datetime, timezone

from db_utils import get_db_connection
from trade_logger import log_event
from bybit_wrapper import AsyncBybitWrapper
from risk_controls import update_pnl

# --- ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ ---
MANAGER_LOOP_SLEEP_INTERVAL = 15
ENTRY_GRID_ORDERS = 3

# ==============================================================================
# 1. Ğ—ĞĞ”ĞĞ§Ğ Ğ ĞĞ—ĞœĞ•Ğ©Ğ•ĞĞ˜Ğ¯ ĞĞ Ğ”Ğ•Ğ ĞĞ’ (ÑƒĞ¶Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¹)
# ==============================================================================
async def place_entry_grid(trade_id: int, total_qty: float, instruction: dict, bybit_client: AsyncBybitWrapper):
    """
    Ğ’Ñ‹ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞµÑ‚ĞºÑƒ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ½Ñ‹Ñ… Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ² Ğ½Ğ° Ğ²Ñ…Ğ¾Ğ´ Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ´ĞµĞ»ĞºĞ¸.
    Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ²Ğ¾Ğ¸Ğ¼ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ñ Ğ‘Ğ”.
    """
    conn = get_db_connection()
    try:
        existing_orders = conn.execute("SELECT 1 FROM entry_orders WHERE trade_id = ?", (trade_id,)).fetchone()
        if existing_orders:
            log_event("GRID_PLACEMENT_SKIPPED", {"reason": "already_exists", "trade_id": trade_id})
            return

        precision = bybit_client.get_market_precision(instruction['symbol'])
        if not precision or not precision.get('amount'):
            log_event("GRID_PLACEMENT_ERROR", {"reason": "missing_precision", "trade_id": trade_id})
            return

        amount_step = precision.get('amount', 1e-8) # Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
        order_qty = round(total_qty / ENTRY_GRID_ORDERS, int(-np.log10(amount_step)))
        if order_qty <= 0:
            log_event("GRID_PLACEMENT_ERROR", {"reason": "zero_order_qty", "trade_id": trade_id})
            return
            
        entry_prices = np.linspace(instruction['entry_start'], instruction['entry_end'], ENTRY_GRID_ORDERS)
        
        with conn:
            for price in entry_prices:
                try:
                    order = await bybit_client.create_limit_order(
                        symbol=instruction['symbol'], side=instruction['side'], amount=order_qty, price=price
                    )
                    log_event("ENTRY_ORDER_PLACED", {"trade_id": trade_id, "order_id": order['id'], "price": price})
                    conn.execute(
                        "INSERT INTO entry_orders (trade_id, exchange_order_id, status) VALUES (?, ?, ?)",
                        (trade_id, order['id'], 'open')
                    )
                except Exception as e:
                    log_event("ENTRY_ORDER_FAILED", {"trade_id": trade_id, "price": price, "error": str(e)})
    finally:
        if conn:
            conn.close()

# ==============================================================================
# 2. Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ Ğ¦Ğ˜ĞšĞ› ĞœĞ•ĞĞ•Ğ”Ğ–Ğ•Ğ Ğ (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ)
# ==============================================================================
async def position_manager_loop(bybit_client: AsyncBybitWrapper):
    """Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ», ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ²ÑĞµĞ¼Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼Ğ¸ Ğ¸ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğ¼Ğ¸ ÑĞ´ĞµĞ»ĞºĞ°Ğ¼Ğ¸."""
    log_event("POSITION_MANAGER_STARTED", {})
    while True:
        try:
            trades_to_manage = []
            conn = get_db_connection()
            try:
                # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑĞ´ĞµĞ»Ğ¾Ğº Ğ¸ ÑÑ€Ğ°Ğ·Ñƒ Ğ·Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
                trades_to_manage_rows = conn.execute("SELECT * FROM managed_trades WHERE status != 'CLOSED'").fetchall()
                trades_to_manage = [dict(row) for row in trades_to_manage_rows]
            finally:
                conn.close()
            
            if not trades_to_manage:
                await asyncio.sleep(MANAGER_LOOP_SLEEP_INTERVAL)
                continue

            live_positions = await bybit_client.fetch_open_positions()
            
            active_symbols = {trade['symbol'] for trade in trades_to_manage}
            if active_symbols:
                # Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑĞ°Ğ¼Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ²Ğ¾Ğ¸Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ĞµĞ¼
                await update_live_prices(bybit_client, list(active_symbols))
            
            for trade in trades_to_manage:
                # ĞŸĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ bybit_client, Ğ½Ğ¾ Ğ½Ğµ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
                await reconcile_and_manage(trade, live_positions.get(trade['symbol']), bybit_client)
                
        except asyncio.CancelledError:
            log_event("POSITION_MANAGER_STOPPED", {})
            break
        except Exception as e:
            log_event("POSITION_MANAGER_ERROR", {"error": str(e), "context": "Main Loop"})
        
        await asyncio.sleep(MANAGER_LOOP_SLEEP_INTERVAL)

# ==============================================================================
# 3. Ğ›ĞĞ“Ğ˜ĞšĞ Ğ¡Ğ’Ğ•Ğ ĞšĞ˜ Ğ˜ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ¯ (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ)
# ==============================================================================
async def reconcile_and_manage(trade: dict, live_position: dict, bybit_client: AsyncBybitWrapper):
    """
    Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚ĞµĞ¹Ñ‚-Ğ¼Ğ°ÑˆĞ¸Ğ½Ğ° Ğ´Ğ»Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ ÑĞ´ĞµĞ»ĞºĞ¸.
    Ğ‘Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ 'conn', Ğ° ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸.
    """
    trade_id = trade['id']
    status = trade['status']
    now_utc = datetime.now(timezone.utc).isoformat(timespec='microseconds')

    try:
        # --- Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: PENDING_ENTRY -> ACTIVE ---
        if status == 'PENDING_ENTRY' and live_position:
            avg_price = float(live_position['entryPrice'])
            exec_qty = float(live_position['contracts'])
            log_event("ENTRY_DETECTED", {"trade_id": trade_id, "avg_price": avg_price, "qty": exec_qty})
            
            sl_order = await bybit_client.create_order(
                symbol=trade['symbol'], type='market', side='buy' if trade['side'] == 'short' else 'sell',
                amount=exec_qty, params={'stopLoss': trade['initial_sl_price'], 'reduceOnly': True}
            )
            sl_order_id = sl_order.get('id')
            
            conn = get_db_connection()
            try:
                entry_orders_to_cancel = conn.execute("SELECT exchange_order_id FROM entry_orders WHERE trade_id = ? AND status = 'open'", (trade_id,)).fetchall()
            finally:
                conn.close()

            for order_row in entry_orders_to_cancel:
                await bybit_client.cancel_order(order_row['exchange_order_id'], trade['symbol'])

            conn = get_db_connection()
            try:
                with conn:
                    conn.execute(
                        "UPDATE managed_trades SET status=?, avg_entry_price=?, executed_qty=?, exchange_sl_order_id=?, updated_at=? WHERE id=?",
                        ('ACTIVE', avg_price, exec_qty, sl_order_id, now_utc, trade_id)
                    )
                    conn.execute("UPDATE entry_orders SET status='cancelled' WHERE trade_id=? AND status='open'", (trade_id,))
                log_event("TRADE_ACTIVATED", {"trade_id": trade_id, "sl_order_id": sl_order_id})
            finally:
                conn.close()

        # --- Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ACTIVE -> CLOSED ---
        elif status == 'ACTIVE' and not live_position:
            # ... (ĞºĞ¾Ğ´ Ğ²Ñ‹ÑˆĞµ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹) ...
            pnl, reason = await get_realized_pnl(trade, bybit_client)

            conn = get_db_connection()
            try:
                with conn:
                    # Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•: Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°ÑÑ‰Ğ¸Ğ¹ UPDATE-Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ
                    conn.execute(
                        "UPDATE managed_trades SET status='CLOSED', close_reason=?, realized_pnl=?, updated_at=? WHERE id=?",
                        (reason, pnl, now_utc, trade_id)
                    )
                # Ğ£Ğ±ĞµĞ´Ğ¸Ğ¼ÑÑ, Ñ‡Ñ‚Ğ¾ PnL Ğ½Ğµ None Ğ¿ĞµÑ€ĞµĞ´ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸ĞµĞ¼
                if pnl is not None:
                    update_pnl(conn, pnl) 
            finally:
                conn.close()
            log_event("PNL_UPDATED", {"trade_id": trade_id, "pnl": pnl})

        # --- Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ACTIVE (Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ TP / SL) ---
        elif status == 'ACTIVE' and live_position:
            remaining_tps = json.loads(trade['remaining_tps'])
            if not remaining_tps: return

            mark_price = float(live_position['markPrice'])
            next_tp_price = remaining_tps[0]

            tp_hit = (trade['side'] == 'long' and mark_price >= next_tp_price) or \
                     (trade['side'] == 'short' and mark_price <= next_tp_price)

            if tp_hit:
                initial_tps_count = len(json.loads(trade['initial_tps']))
                precision = bybit_client.get_market_precision(trade['symbol'])
                amount_step = precision.get('amount', 1e-8)
                tp_qty = round(trade['total_qty'] / initial_tps_count, int(-np.log10(amount_step)))
                
                if tp_qty > 0:
                    await bybit_client.create_limit_order(
                        symbol=trade['symbol'], side='buy' if trade['side'] == 'short' else 'sell',
                        amount=tp_qty, price=next_tp_price, params={'reduceOnly': True}
                    )
                
                remaining_tps.pop(0)
                conn = get_db_connection()
                try:
                    with conn:
                        conn.execute("UPDATE managed_trades SET remaining_tps=?, updated_at=? WHERE id=?", (json.dumps(remaining_tps), now_utc, trade_id))
                    log_event("TP_ORDER_PLACED", {"trade_id": trade_id, "tp_price": next_tp_price})
                finally:
                    conn.close()
            
            initial_tps_count = len(json.loads(trade['initial_tps']))
            tps_taken = initial_tps_count - len(remaining_tps)
            
            if (trade.get('move_sl_to_be_after_tp_index') is not None and 
                tps_taken >= trade['move_sl_to_be_after_tp_index'] and 
                trade['avg_entry_price'] is not None and
                trade['current_sl_price'] != trade['avg_entry_price']):
                
                new_sl_price = trade['avg_entry_price']
                log_event("MOVING_SL_TO_BREAKEVEN", {"trade_id": trade_id, "new_sl": new_sl_price})
                
                await bybit_client.edit_order(
                    trade['exchange_sl_order_id'], trade['symbol'], new_sl_price
                )
                conn = get_db_connection()
                try:
                    with conn:
                        conn.execute("UPDATE managed_trades SET current_sl_price=?, updated_at=? WHERE id=?", (new_sl_price, now_utc, trade_id))
                    log_event("SL_MOVE_SUCCESS", {"trade_id": trade_id})
                finally:
                    conn.close()

    except Exception as e:
        log_event("RECONCILE_ERROR", {"trade_id": trade_id, "error": str(e), "status": status})

# ==============================================================================
# 4. Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ)
# ==============================================================================
async def update_live_prices(bybit_client: AsyncBybitWrapper, symbols: list):
    """Ğ—Ğ°Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°ĞµÑ‚ Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ Ğ¶Ğ¸Ğ²Ñ‹Ğµ Ñ†ĞµĞ½Ñ‹, ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑ ÑĞ²Ğ¾Ğ¸Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ĞµĞ¼."""
    conn = get_db_connection()
    try:
        tickers = await asyncio.gather(*[bybit_client.fetch_ticker_price(s) for s in symbols])
        now_utc = datetime.now(timezone.utc).isoformat(timespec='microseconds')
        
        with conn:
            for symbol, price in zip(symbols, tickers):
                if price > 0:
                    conn.execute(
                        "INSERT OR REPLACE INTO live_prices (symbol, mark_price, updated_at) VALUES (?, ?, ?)",
                        (symbol, price, now_utc)
                    )
    except Exception as e:
        log_event("LIVE_PRICE_UPDATE_ERROR", {"error": str(e)})
    finally:
        if conn:
            conn.close()

async def get_realized_pnl(trade: dict, bybit_client: AsyncBybitWrapper) -> tuple[float, str]:
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ´ĞµĞ»Ğ¾Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ñ Ğ±Ğ¸Ñ€Ğ¶Ğ¸ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑ‡ĞµÑ‚Ğ° PnL.
    Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ½Ğµ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²ÑƒĞµÑ‚ Ñ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ‘Ğ”.
    """
    try:
        my_trades = await bybit_client.fetch_my_trades(trade['symbol'], limit=20)
        
        trade_open_time = datetime.fromisoformat(trade['created_at'])
        relevant_trades = [t for t in my_trades if t.get('timestamp') and datetime.fromtimestamp(t['timestamp'] / 1000, tz=timezone.utc) > trade_open_time]
        
        if not relevant_trades:
            return 0.0, "UNKNOWN_NO_TRADES"

        realized_pnl = sum(t.get('fee', {}).get('cost', 0) * -1 for t in relevant_trades if t.get('fee'))

        last_trade = relevant_trades[-1]
        if last_trade.get('price') and trade.get('current_sl_price') and last_trade['price'] == trade['current_sl_price']:
            return realized_pnl, "SL_HIT"
        elif last_trade.get('price') and trade.get('initial_tps') and last_trade['price'] in json.loads(trade['initial_tps']):
             return realized_pnl, "TP_HIT"
        else:
            return realized_pnl, "MANUAL_OR_OTHER"

    except Exception as e:
        log_event("PNL_FETCH_ERROR", {"trade_id": trade['id'], "error": str(e)})
        return 0.0, "ERROR_FETCHING_PNL"

ğŸ”¹ File: risk_controls.py
----------------------------------------------
# file: risk_controls.py
import sqlite3
import os
from datetime import date, datetime 
from functools import wraps
from fastapi import HTTPException

# --- CHANGE 1: Import the central DB connection utility ---
from db_utils import get_db_connection

# --- CHANGE 2: Remove the local get_db_connection() and initialize_pnl_table() functions ---
# They are no longer needed here.

INITIAL_EQUITY = 1000.0

def check_daily_drawdown(max_loss_pct: float = 0.03):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            today = date.today()
            # This call now correctly uses the function from db_utils,
            # which is properly patched by your tests.
            conn = get_db_connection()
            cursor = conn.cursor()
            
            current_equity = INITIAL_EQUITY
            max_loss_usd = current_equity * max_loss_pct

            try:
                cursor.execute("SELECT realised_pnl FROM daily_pnl WHERE trade_date = ?", (today,))
                result = cursor.fetchone()
                realised_pnl = result['realised_pnl'] if result else 0.0
            except sqlite3.OperationalError as e:
                # Handle case where table might not exist in a faulty setup, but log it.
                print(f"Database error in check_daily_drawdown: {e}")
                realised_pnl = 0.0
            finally:
                conn.close()

            if realised_pnl <= -max_loss_usd:
                raise HTTPException(
                    status_code=429,
                    detail=f"Daily loss limit of ${max_loss_usd:.2f} reached. Realised PnL: ${realised_pnl:.2f}. No new trades allowed."
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# --- CHANGE 3: Modify update_pnl to accept a connection object ---
def update_pnl(conn: sqlite3.Connection, pnl: float):
    """Updates the PnL for the current day using the provided connection."""
    
    # --- ĞĞĞ¨Ğ ĞĞ¢Ğ›ĞĞ”ĞĞ§ĞĞĞ¯ Ğ›ĞĞ’Ğ£Ğ¨ĞšĞ ---
    now = datetime.now().strftime("%H:%M:%S.%f")
    print(f"\nDEBUG_TRAP [{now}]: update_pnl CALLED! PNL = {pnl}\n")
    # ---------------------------------
    
    today = date.today()
    try:
        with conn:
            conn.execute('''
                INSERT INTO daily_pnl (trade_date, realised_pnl)
                VALUES (?, ?)
                ON CONFLICT(trade_date) DO UPDATE SET
                realised_pnl = realised_pnl + excluded.realised_pnl;
            ''', (today, pnl))
    except Exception as e:
        print(f"ERROR in update_pnl: {e}")

ğŸ”¹ File: risk_sizer.py
----------------------------------------------
# File: risk_sizer.py
import math

RISK_PER_TRADE_PCT = 0.01

def calculate_position_size(
    entry_price: float,
    stop_loss_price: float,
    equity: float,
    amount_precision_step: float,
    risk_pct: float = RISK_PER_TRADE_PCT
) -> float:
    
    price_diff = abs(entry_price - stop_loss_price)
    if equity <= 0 or price_diff == 0:
        return 0.0
        
    risk_per_trade_usd = equity * risk_pct
    position_size = risk_per_trade_usd / price_diff

    # Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ±Ğ¾Ğ»ĞµĞµ Ğ½Ğ°Ğ´ĞµĞ¶Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ¾ĞºÑ€ÑƒĞ³Ğ»ĞµĞ½Ğ¸Ñ
    if amount_precision_step == 1:
        # Ğ”Ğ»Ñ Ñ†ĞµĞ»Ñ‹Ñ… Ñ‡Ğ¸ÑĞµĞ» (ĞºĞ°Ğº SHIB) Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ¾Ğµ Ğ¾ĞºÑ€ÑƒĞ³Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ Ñ†ĞµĞ»Ğ¾Ğ³Ğ¾
        return round(position_size)
    else:
        # Ğ”Ğ»Ñ Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ñ… - Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ½Ğ°ĞºĞ¾Ğ² Ğ¸Ğ· ÑˆĞ°Ğ³Ğ°
        decimal_places = -int(math.log10(amount_precision_step))
        return round(position_size, decimal_places)

ğŸ”¹ File: signal_parser.py
----------------------------------------------
# file: signal_parser.py
import re
import hashlib
from typing import Optional
from models import TradeInstruction

def parse_pentagon_signal(text: str) -> Optional[TradeInstruction]:
    """ĞŸĞ°Ñ€ÑĞ¸Ñ‚ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞºÑ‚ TradeInstruction."""
    try:
        side_match = re.search(r'(Ğ»Ğ¾Ğ½Ğ³|ÑˆĞ¾Ñ€Ñ‚)', text, re.IGNORECASE)
        side = 'long' if 'Ğ»Ğ¾Ğ½Ğ³' in side_match.group(0).lower() else 'short'

        entry_match = re.search(r'(\d{4,6})-(\d{4,6})', text)
        entry_start, entry_end = sorted([float(entry_match.group(1)), float(entry_match.group(2))])

        sl_match = re.search(r'ÑÑ‚Ğ¾Ğ¿\s*(?:Ğ¿Ğ¾Ğ´|Ğ½Ğ°Ğ´)?\s*(\d+\.?\d*)', text, re.IGNORECASE)
        stop_loss = float(sl_match.group(1))

        risk_match = re.search(r'Ñ€Ğ¸ÑĞºĞ¾Ğ¼\s+([\d.]+)\s*%\s*\((\d\/\d)\)', text, re.IGNORECASE)
        risk_pct = float(risk_match.group(1)) / 100
        num, den = map(int, risk_match.group(2).split('/'))
        size_fraction = num / den

        targets_block_match = re.search(r'Ğ¦ĞµĞ»Ğ¸:([\s\S]*?)(?:\n\n|\Z)', text, re.IGNORECASE)
        targets_block = targets_block_match.group(1)
        take_profits = [float(tp) for tp in re.findall(r'(\d{4,6})', targets_block)]
        if not take_profits:
            raise ValueError("No take profits found in signal")

        signal_id = hashlib.md5(text.encode()).hexdigest()

        return TradeInstruction(
            signal_id=signal_id,
            side=side,
            entry_start=entry_start,
            entry_end=entry_end,
            stop_loss=stop_loss,
            risk_pct=risk_pct,
            size_fraction=size_fraction,
            take_profits=take_profits,
        )
    except (AttributeError, ValueError, IndexError) as e:
        print(f"Signal parsing failed: {e}")
        return None

ğŸ”¹ File: spring_model.py
----------------------------------------------
import pandas as pd
import numpy as np

def bounce_prob(
    bars: pd.DataFrame,
    side: str,
    price: float,
    bb_window: int = 20,
    bb_std_dev: float = 2.0
) -> float:
    """
    Calculates the 'bounce probability' based on a Bollinger Band mean-reversion model.

    Args:
        bars: DataFrame with historical data, must contain a 'close' column.
        side: The trade side, either 'long' or 'short'.
        price: The current price to evaluate.
        bb_window: The moving average window for Bollinger Bands.
        bb_std_dev: The standard deviation multiplier for Bollinger Bands.

    Returns:
        A probability score [0, 1] indicating the likelihood of a bounce.
    """
    if side not in ['long', 'short']:
        raise ValueError("Side must be either 'long' or 'short'.")

    if len(bars) < bb_window:
        # Not enough data to calculate BBs, no basis for a bounce.
        return 0.0

    # Calculate Bollinger Bands from the historical bars
    closes = bars['close']
    mu = closes.rolling(window=bb_window).mean().iloc[-1]
    sigma = closes.rolling(window=bb_window).std().iloc[-1]

    # Handle case of zero volatility to prevent division by zero
    if sigma == 0:
        return 0.0

    lower_bb = mu - bb_std_dev * sigma
    upper_bb = mu + bb_std_dev * sigma
    p_raw = 0.0

    if side == "long":
        # Probability increases as price drops further below the lower band.
        if price < lower_bb:
            p_raw = (lower_bb - price) / (bb_std_dev * sigma)
    else:  # side == "short"
        # Probability increases as price rises further above the upper band.
        if price > upper_bb:
            p_raw = (price - upper_bb) / (bb_std_dev * sigma)
    
    # Clip the result to be within the valid probability range [0, 1]
    return float(np.clip(p_raw, 0, 1))

ğŸ”¹ File: tests/__init__.py
----------------------------------------------
# This file is intentionally left empty.
# It marks the 'tests' directory as a Python package.

ğŸ”¹ File: tests/conftest.py
----------------------------------------------
# file: tests/conftest.py
import pytest
import os
import sqlite3
from unittest.mock import AsyncMock, MagicMock  # <-- Import MagicMock
from fastapi.testclient import TestClient
from datetime import datetime, timezone        # <-- ADD THIS LINE

TEST_DB_FILE = "test_app_db.sqlite"

@pytest.fixture(scope="function", autouse=True)
def setup_for_every_test(monkeypatch, mocker):
    # 1. Isolate the database by deleting files
    monkeypatch.setenv("DATABASE_FILE", TEST_DB_FILE)
    if os.path.exists(TEST_DB_FILE): os.remove(TEST_DB_FILE)
    if os.path.exists(f"{TEST_DB_FILE}-shm"): os.remove(f"{TEST_DB_FILE}-shm")
    if os.path.exists(f"{TEST_DB_FILE}-wal"): os.remove(f"{TEST_DB_FILE}-wal")
    
    # 2. Setup schema in the new, clean file
    from db_setup import setup_database
    setup_database()

    # 3. Mock external services
    mock_main_bybit_client = AsyncMock(name="main_bybit_client_mock")
    mock_main_bybit_client.set_sandbox_mode = MagicMock()
    mock_main_bybit_client.init.return_value = None
    mock_main_bybit_client.get_usdt_balance.return_value = 1000.0
    mock_main_bybit_client.get_market_precision.return_value = {'amount': 0.001, 'price': 0.01}
    mock_main_bybit_client.fetch_open_positions.return_value = {}
    mock_main_bybit_client.fetch_my_trades.return_value = []
    mocker.patch('main.bybit_client', new=mock_main_bybit_client)

    mocker.patch('main.position_manager_loop', new_callable=AsyncMock)
    mocker.patch('main.place_entry_grid', new_callable=AsyncMock)
    
    yield

@pytest.fixture
def test_app_client():
    """Provides a TestClient to the app. The app is now safe to use
    because the autouse fixture has already cleaned and mocked everything."""
    from main import app
    with TestClient(app) as client:
        yield client

# This fixture is for non-API tests that need a standalone mock client.
# It's different from the one used by the app, ensuring no cross-contamination.
@pytest.fixture
def mock_bybit_client():
    """
    Provides a standalone mock client for non-API unit tests.
    """
    client = AsyncMock(name="standalone_mock_bybit_client")
    client.get_market_precision.return_value = {'amount': 0.001, 'price': 0.01}
    client.create_order.return_value = {"id": "stop_loss_order_1"}
    
    # --- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ”Ğ›Ğ¯ PNL ---
    # Ğ¡Ğ¸Ğ¼ÑƒĞ»Ğ¸Ñ€ÑƒĞµĞ¼, Ñ‡Ñ‚Ğ¾ fetch_my_trades Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¾Ğ´Ğ½Ñƒ ÑĞ´ĞµĞ»ĞºÑƒ Ñ Ğ½ÑƒĞ»ĞµĞ²Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸ĞµĞ¹.
    # Ğ­Ñ‚Ğ¾ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»Ğ¸Ñ‚ get_realized_pnl Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ 0.0, Ğ° Ğ½Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ.
    client.fetch_my_trades.return_value = [
        {'timestamp': datetime.now(timezone.utc).timestamp() * 1000, 'fee': {'cost': 0.0}}
    ]
    # ---------------------------

    return client

ğŸ”¹ File: tests/test_api_process_signal.py
----------------------------------------------
# file: tests/test_api_process_signal.py
import pytest
from unittest.mock import AsyncMock
from db_utils import get_db_connection


VALID_SIGNAL_TEXT = "ğŸ”´Ğ¿Ñ€Ğ¾Ğ±ÑƒÑ ÑˆĞ¾Ñ€Ñ‚ 109200-110500 Ğ¸ Ñ€Ğ¸ÑĞºĞ¾Ğ¼ 0.5% (1/2) ÑÑ‚Ğ¾Ğ¿ Ğ½Ğ°Ğ´ 111500\nĞ¦ĞµĞ»Ğ¸: 109000"

def test_api_db_is_clean_before_run(test_app_client):
    """
    Verifies that the database is clean at the start of an API test.
    The app factory pattern ensures no state leaks from previous tests.
    """
    conn = get_db_connection()
    try:
        pnl_record = conn.execute("SELECT * FROM daily_pnl").fetchone()
    finally:
        conn.close()
    
    assert pnl_record is None, "The daily_pnl table should be empty."

def test_process_signal_creates_trade_in_db(test_app_client, mock_place_entry_grid):
    """
    Tests the full API endpoint flow from signal to DB record.
    """
    response = test_app_client.post("/process_signal", params={"raw_text": VALID_SIGNAL_TEXT})

    assert response.status_code == 202, f"API returned an unexpected status. Body: {response.text}"
    data = response.json()
    assert data['status'] == 'accepted'
    trade_id = data['trade_id']

    conn = get_db_connection()
    try:
        trade_in_db = conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone()
    finally:
        conn.close()
    
    assert trade_in_db is not None
    assert trade_in_db['status'] == 'PENDING_ENTRY'
    assert trade_in_db['side'] == 'short'

    mock_place_entry_grid.assert_called_once()
    args, _ = mock_place_entry_grid.call_args
    assert args[0] == trade_id

ğŸ”¹ File: tests/test_backtest_runner.py
----------------------------------------------
import pytest
import pandas as pd
import numpy as np
from backtest_runner import run_backtest, calculate_metrics

def test_backtest_run(monkeypatch): # <-- ADDED monkeypatch
    # Create synthetic data with some volatility to prevent sigma=0
    prices = pd.DataFrame({
        'ts': range(100, 200),
        'close': list(np.linspace(101, 100, 50)) + list(np.linspace(91, 90, 50)),
        'low': list(np.linspace(100, 99, 50)) + list(np.linspace(86, 85, 50)),
        'high': list(np.linspace(102, 101, 50)) + list(np.linspace(96, 95, 50))
    })
    signals = pd.DataFrame({
        'ts': [150],
        'side': ['long'],
        'entry': [90],
        'sl': [88]
    })
    
    # Use monkeypatch to correctly override the function in the target module
    monkeypatch.setattr("backtest_runner.bounce_prob", lambda *args, **kwargs: 1.0)
    
    equity_curve, trades = run_backtest(prices, signals, bb_window=20, bb_std_dev=2.0)
    
    assert len(trades) > 0
    assert equity_curve[-1] != 1000.0

def test_metrics_calculation():
    equity_curve = [1000, 1010, 1005, 1020, 1015]
    total_r, max_dd, sharpe = calculate_metrics(equity_curve, num_days=1)
    
    assert total_r == pytest.approx(0.015)
    # The calculated value is -0.004950495...
    assert max_dd == pytest.approx(-0.00495, abs=1e-5)
    assert sharpe is not None

ğŸ”¹ File: tests/test_bybit_wrapper.py
----------------------------------------------
import pytest
from unittest.mock import AsyncMock, MagicMock
import ccxt.async_support as ccxt
from bybit_wrapper import AsyncBybitWrapper

@pytest.fixture
def mock_exchange():
    """Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ°, ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‰Ğ°Ñ Ğ¼Ğ¾Ğº-Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ğ´Ğ»Ñ ccxt.exchange."""
    exchange = AsyncMock()
    exchange.load_markets.return_value = None
    exchange.set_sandbox_mode = MagicMock(return_value=None) # <-- MODIFY THIS LINE
    exchange.fetch_balance.return_value = {
        'USDT': {'free': 1000.0, 'used': 0.0, 'total': 1000.0}
    }
    exchange.create_order.return_value = {'id': '12345', 'status': 'open'}
    exchange.market.return_value = {
        'precision': {'amount': 3, 'price': 2}
    }
    return exchange


@pytest.mark.asyncio
async def test_init_and_get_balance(mock_exchange, mocker):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑƒÑĞ¿ĞµÑˆĞ½ÑƒÑ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°."""
    # ĞŸĞ¾Ğ´Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ccxt.bybit Ğ½Ğ° Ğ½Ğ°Ñˆ Ğ¼Ğ¾Ğº
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€ Ñ Ñ„Ğ¸ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼Ğ¸ ĞºĞ»ÑÑ‡Ğ°Ğ¼Ğ¸
    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    balance = await wrapper.get_usdt_balance()
    await wrapper.close()

    assert balance == 1000.0
    mock_exchange.load_markets.assert_called_once()
    mock_exchange.fetch_balance.assert_called_once()


@pytest.mark.asyncio
async def test_create_order_success(mock_exchange, mocker):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°."""
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    mock_log = mocker.patch('bybit_wrapper.log_trade_execution')
    
    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    result = await wrapper.create_market_order_with_sl('BTC/USDT:USDT', 'buy', 0.01, 59000.0)
    await wrapper.close()

    assert result['id'] == '12345'
    mock_log.assert_called_once()


@pytest.mark.asyncio
async def test_create_order_insufficient_funds(mock_exchange, mocker):
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ½ĞµÑ…Ğ²Ğ°Ñ‚ĞºĞ¸ ÑÑ€ĞµĞ´ÑÑ‚Ğ²."""
    error_message = "bybit-insufficient-balance-for-order-cost"
    mock_exchange.create_order.side_effect = ccxt.InsufficientFunds(error_message)
    mocker.patch('ccxt.async_support.bybit', return_value=mock_exchange)
    mock_log = mocker.patch('bybit_wrapper.log_trade_execution')

    wrapper = AsyncBybitWrapper(api_key="dummy", secret_key="dummy", testnet=True)
    await wrapper.init()
    result = await wrapper.create_market_order_with_sl('BTC/USDT:USDT', 'buy', 1.0, 59000.0)
    await wrapper.close()

    assert 'error' in result
    assert error_message in result['error']
    mock_log.assert_called_once()

ğŸ”¹ File: tests/test_position_manager.py
----------------------------------------------
# file: tests/test_position_manager.py
import pytest
import json
from datetime import datetime, timezone
from unittest.mock import AsyncMock

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ
from position_manager import reconcile_and_manage
# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑƒÑ‚Ğ¸Ğ»Ğ¸Ñ‚Ñƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
from db_utils import get_db_connection

# --- Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ´ĞµĞ»Ğ¾Ğº Ğ² Ğ‘Ğ” ---

def create_test_trade_in_db(status='PENDING_ENTRY', avg_price=None, sl_price=85.0, sl_order_id=None, remaining_tps='[110, 120]', move_sl_idx=1, total_qty=1.0):
    """
    Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾ ÑĞ´ĞµĞ»ĞºĞµ Ğ² Ğ‘Ğ” Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞµĞµ ID.
    Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑĞ°Ğ¼Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ²Ğ¾Ğ¸Ğ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ñ Ğ‘Ğ”.
    """
    conn = get_db_connection()
    try:
        now_utc_iso = datetime.now(timezone.utc).isoformat()
        cursor = conn.cursor()
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²ÑĞµ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
        initial_tps_json = json.dumps([110, 120])
        remaining_tps_json = remaining_tps if isinstance(remaining_tps, str) else json.dumps(remaining_tps)
        
        cursor.execute("""
            INSERT INTO managed_trades (
                instruction_id, symbol, side, status, entry_range_start, entry_range_end,
                total_qty, avg_entry_price, initial_sl_price, current_sl_price, exchange_sl_order_id,
                initial_tps, remaining_tps, move_sl_to_be_after_tp_index, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            'sig1', 'BTCUSDT', 'long', status, 90.0, 100.0, total_qty, avg_price, 85.0, sl_price,
            sl_order_id, initial_tps_json, remaining_tps_json, move_sl_idx, now_utc_iso, now_utc_iso
        ))
        trade_id = cursor.lastrowid
        conn.commit()
    finally:
        conn.close()
    return trade_id

# === Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° Ñ‚ĞµÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ reconcile_and_manage ===

@pytest.mark.asyncio
async def test_reconcile_pending_to_active(mock_bybit_client):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ¸Ğ· PENDING_ENTRY Ğ² ACTIVE.
    """
    # 1. ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ°: ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞ´ĞµĞ»ĞºÑƒ Ğ¸ Ğ¾Ñ€Ğ´ĞµÑ€ Ğ² Ñ‡Ğ¸ÑÑ‚Ğ¾Ğ¹ Ğ‘Ğ”.
    # Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° `setup_for_every_test` Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ‘Ğ” Ñ‡Ğ¸ÑÑ‚Ğ°.
    trade_id = create_test_trade_in_db(status='PENDING_ENTRY')
    
    conn = get_db_connection()
    try:
        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ID Ğ´Ğ»Ñ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ½Ğµ Ğ±ÑƒĞ´ĞµÑ‚ ĞºĞ¾Ğ½Ñ„Ğ»Ğ¸ĞºÑ‚Ğ¾Ğ²Ğ°Ñ‚ÑŒ
        conn.execute("INSERT INTO entry_orders (trade_id, exchange_order_id, status) VALUES (?, ?, 'open')", (trade_id, f"entry_order_{trade_id}"))
        conn.commit()
        trade_before = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    finally:
        conn.close()

    # 2. Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ: "Ğ½Ğ° Ğ±Ğ¸Ñ€Ğ¶Ğµ" Ğ¿Ğ¾ÑĞ²Ğ¸Ğ»Ğ°ÑÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
    live_position_mock = {
        'symbol': 'BTCUSDT',
        'entryPrice': '95.5',
        'contracts': '0.5',
        'markPrice': '96.0'
    }
    
    # 3. Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ: Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ
    await reconcile_and_manage(trade_before, live_position_mock, mock_bybit_client)

    # 4. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°
    conn = get_db_connection()
    try:
        trade_after = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    finally:
        conn.close()
    
    assert trade_after['status'] == 'ACTIVE'
    assert trade_after['avg_entry_price'] == 95.5
    assert trade_after['executed_qty'] == 0.5
    # mock_bybit_client Ğ¸Ğ· conftest.py Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ 'stop_loss_order_1'
    assert trade_after['exchange_sl_order_id'] == 'stop_loss_order_1' 
    mock_bybit_client.cancel_order.assert_called_once_with(f"entry_order_{trade_id}", 'BTCUSDT')

@pytest.mark.asyncio
async def test_reconcile_active_to_closed(mock_bybit_client):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ¸Ğ· ACTIVE Ğ² CLOSED.
    """
    trade_id = create_test_trade_in_db(status='ACTIVE', avg_price=95.0)
    
    conn = get_db_connection()
    trade_before = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    live_position_mock = None
    
    await reconcile_and_manage(trade_before, live_position_mock, mock_bybit_client)

    conn = get_db_connection()
    trade_after = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    # Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ÑÑ‚Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸, Ñ‚Ğ°Ğº ĞºĞ°Ğº get_realized_pnl Ğ½Ğµ Ğ²Ñ‹Ğ·Ğ¾Ğ²ĞµÑ‚ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ
    assert trade_after['status'] == 'CLOSED'
    assert trade_after['close_reason'] is not None

@pytest.mark.asyncio
async def test_reconcile_moves_sl_to_breakeven(mock_bybit_client):
    """
    Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑĞ° Ğ² Ğ±ĞµĞ·ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº.
    """
    # --- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• ĞĞ¨Ğ˜Ğ‘ĞšĞ˜ ---
    # Ğ—Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ pytest.AsyncMock Ğ½Ğ° AsyncMock Ğ¸Ğ· unittest.mock
    mock_bybit_client.edit_order = AsyncMock(return_value={"id": "sl_edited_456"})
    # ---------------------------
    
    trade_id = create_test_trade_in_db(
        status='ACTIVE', avg_price=95.0, sl_price=85.0,
        sl_order_id='sl_initial_123', remaining_tps='[120]', move_sl_idx=1
    )
    
    conn = get_db_connection()
    trade_before = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    live_position_mock = {
        'symbol': 'BTCUSDT', 'entryPrice': '95.0',
        'contracts': '0.5', 'markPrice': '115.0'
    }
    
    await reconcile_and_manage(trade_before, live_position_mock, mock_bybit_client)

    conn = get_db_connection()
    trade_after = dict(conn.execute("SELECT * FROM managed_trades WHERE id = ?", (trade_id,)).fetchone())
    conn.close()

    assert trade_after['current_sl_price'] == trade_after['avg_entry_price']
    
    mock_bybit_client.edit_order.assert_called_once_with(
        'sl_initial_123', 'BTCUSDT', 95.0
    )

ğŸ”¹ File: tests/test_risk_controls.py
----------------------------------------------
# file: tests/test_risk_controls.py
import pytest
import numpy as np
from datetime import date
from fastapi import HTTPException

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
from risk_controls import check_daily_drawdown, update_pnl
# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑƒÑ‚Ğ¸Ğ»Ğ¸Ñ‚Ñƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
from db_utils import get_db_connection

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°
@check_daily_drawdown(max_loss_pct=0.03)
async def dummy_protected_function():
    return {"status": "allowed"}

# ==================== Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ• Ğ¢Ğ•Ğ¡Ğ¢Ğ« ====================
def test_initial_state_is_clean():
    """
    Ğ­Ñ‚Ğ¾Ñ‚ Ñ‚ĞµÑÑ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑ‚ÑŒÑÑ ĞŸĞ•Ğ Ğ’Ğ«Ğœ.
    ĞĞ½ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° daily_pnl Ğ¿ÑƒÑÑ‚Ğ° Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğµ.
    """
    print("\n[DIAGNOSTIC] Running test_initial_state_is_clean...")
    conn = get_db_connection()
    try:
        pnl_record = conn.execute("SELECT * FROM daily_pnl").fetchone()
    finally:
        conn.close()
    
    assert pnl_record is None, "Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜ĞšĞ: Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° daily_pnl ĞĞ• Ğ¿ÑƒÑÑ‚Ğ° Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğµ!"

# === Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° Ñ‚ĞµÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° check_daily_drawdown ===

@pytest.mark.asyncio
async def test_dd_allows_when_no_pnl():
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚: Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµÑ‚ Ğ²Ñ…Ğ¾Ğ´, ĞµÑĞ»Ğ¸ PnL Ğ·Ğ° ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ ĞµÑ‰Ğµ Ğ½ĞµÑ‚."""
    # Ğ‘Ğ” Ñ‡Ğ¸ÑÑ‚Ğ°Ñ Ğ±Ğ»Ğ°Ğ³Ğ¾Ğ´Ğ°Ñ€Ñ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ğµ, Ğ¿Ğ¾ÑÑ‚Ğ¾Ğ¼Ñƒ PnL = 0
    response = await dummy_protected_function()
    assert response == {"status": "allowed"}

@pytest.mark.asyncio
async def test_dd_allows_when_within_limit():
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚: Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµÑ‚ Ğ²Ñ…Ğ¾Ğ´, ĞµÑĞ»Ğ¸ ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº Ğ² Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ñ… Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ°."""
    conn = get_db_connection()
    try:
        update_pnl(conn, -10.0) # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ PnL = -10
    finally:
        conn.close()
    
    # dummy_protected_function ÑƒĞ²Ğ¸Ğ´Ğ¸Ñ‚ PnL = -10.0, Ñ‡Ñ‚Ğ¾ Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ°
    response = await dummy_protected_function()
    assert response == {"status": "allowed"}

@pytest.mark.asyncio
async def test_dd_rejects_when_at_limit():
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚: Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ²Ñ…Ğ¾Ğ´, ĞµÑĞ»Ğ¸ ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº Ñ€Ğ°Ğ²ĞµĞ½ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñƒ."""
    conn = get_db_connection()
    try:
        update_pnl(conn, -30.0) # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ PnL = -30 (Ñ€Ğ°Ğ²ĞµĞ½ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñƒ)
    finally:
        conn.close()
        
    with pytest.raises(HTTPException) as exc_info:
        await dummy_protected_function()
    assert exc_info.value.status_code == 429

@pytest.mark.asyncio
async def test_dd_rejects_when_exceeds_limit():
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚: Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ²Ñ…Ğ¾Ğ´, ĞµÑĞ»Ğ¸ ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº Ğ¿Ñ€ĞµĞ²Ñ‹ÑˆĞ°ĞµÑ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚."""
    conn = get_db_connection()
    try:
        update_pnl(conn, -35.0) # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ PnL = -35
    finally:
        conn.close()
        
    with pytest.raises(HTTPException) as exc_info:
        await dummy_protected_function()
        
    assert exc_info.value.status_code == 429
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ² ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¸ Ğ¾Ğ± Ğ¾ÑˆĞ¸Ğ±ĞºĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ PnL
    assert "-35.00" in exc_info.value.detail


# === Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° Ñ‚ĞµÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ update_pnl ===

def test_update_pnl_accumulates_correctly():
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ñ‡Ñ‚Ğ¾ update_pnl ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾ ÑÑƒĞ¼Ğ¼Ğ¸Ñ€ÑƒĞµÑ‚ PnL Ğ·Ğ° Ğ´ĞµĞ½ÑŒ."""
    conn = get_db_connection()
    try:
        # Ğ­Ñ‚Ğ¸ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´ÑÑ‚ Ğ² Ñ‡Ğ¸ÑÑ‚Ğ¾Ğ¹ Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
        update_pnl(conn, 10.5)
        update_pnl(conn, -5.5)
        update_pnl(conn, 2.0)
        row = conn.execute("SELECT realised_pnl FROM daily_pnl WHERE trade_date = ?", (date.today(),)).fetchone()
    finally:
        conn.close()

    assert row is not None
    pnl = row['realised_pnl']
    # Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ñ€Ğ¾Ğ²Ğ½Ğ¾ 7.0, Ñ‚Ğ°Ğº ĞºĞ°Ğº Ğ½ĞµÑ‚ "Ğ³Ñ€ÑĞ·Ğ½Ñ‹Ñ…" Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ· Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²
    assert np.isclose(pnl, 7.0)

def test_final_state_is_also_clean():
    """
    Ğ­Ñ‚Ğ¾Ñ‚ Ñ‚ĞµÑÑ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑ‚ÑŒÑÑ ĞŸĞĞ¡Ğ›Ğ•Ğ”ĞĞ˜Ğœ Ğ² ÑÑ‚Ğ¾Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ğµ.
    ĞĞ½ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ¾ÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ Ğ»Ğ¸ Ñ‡Ñ‚Ğ¾-Ñ‚Ğ¾ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ².
    """
    print("\n[DIAGNOSTIC] Running test_final_state_is_also_clean...")
    conn = get_db_connection()
    try:
        pnl_record = conn.execute("SELECT * FROM daily_pnl").fetchone()
    finally:
        conn.close()
    
    assert pnl_record is None, "Ğ”Ğ˜ĞĞ“ĞĞĞ¡Ğ¢Ğ˜ĞšĞ: Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° daily_pnl ĞĞ• Ğ¿ÑƒÑÑ‚Ğ° Ğ² ĞºĞ¾Ğ½Ñ†Ğµ!"
# =================================================================

ğŸ”¹ File: tests/test_risk_sizer.py
----------------------------------------------
# File: tests/test_risk_sizer.py
import pytest
from risk_sizer import calculate_position_size

def test_calculate_position_size_btc():
    # step Ğ´Ğ»Ñ BTC = 0.001
    size = calculate_position_size(60000.0, 59000.0, 1000.0, amount_precision_step=0.001)
    assert size == 0.01

def test_calculate_position_size_altcoin():
    # step Ğ´Ğ»Ñ SOL = 0.01
    size = calculate_position_size(150.0, 145.0, 1000.0, amount_precision_step=0.01)
    assert size == 2.0

def test_calculate_position_size_shibcoin():
    # step Ğ´Ğ»Ñ SHIB = 1 (Ñ†ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾)
    size = calculate_position_size(0.000025, 0.000024, 1000.0, amount_precision_step=1)
    # Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ: round(10000000.0) == 10000000
    assert size == 10000000

def test_calculate_position_size_zero_balance():
    size = calculate_position_size(60000.0, 59000.0, 0.0, amount_precision_step=0.001)
    assert size == 0.0

def test_calculate_position_size_zero_price_diff():
    size = calculate_position_size(60000.0, 60000.0, 1000.0, amount_precision_step=0.001)
    assert size == 0.0


ğŸ”¹ File: tests/test_signal_parser.py
----------------------------------------------
# file: tests/test_signal_parser.py
import pytest
from signal_parser import parse_pentagon_signal

# ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
VALID_SIGNAL_TEXT = """
ğŸ”´Ğ¿Ñ€Ğ¾Ğ±ÑƒÑ ÑˆĞ¾Ñ€Ñ‚ 109200-110500 Ğ¸ Ñ€Ğ¸ÑĞºĞ¾Ğ¼ 0.5% (1/2) ÑÑ‚Ğ¾Ğ¿ Ğ½Ğ°Ğ´ 111500, Ğ¿Ğ¾ÑĞ»Ğµ 2Ğ¾Ğ³Ğ¾ Ñ‚ĞµĞ¹ĞºĞ° Ğ² Ğ±Ñƒ
Ğ¦ĞµĞ»Ğ¸: 
109000-108800-108600
"""

# ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¾Ğ¹ (Ğ½ĞµÑ‚ Ñ‚ĞµĞ¹ĞºĞ¾Ğ²)
INVALID_SIGNAL_TEXT = "ğŸ”´Ğ¿Ñ€Ğ¾Ğ±ÑƒÑ ÑˆĞ¾Ñ€Ñ‚ 109200-110500 Ğ¸ Ñ€Ğ¸ÑĞºĞ¾Ğ¼ 0.5% (1/2) ÑÑ‚Ğ¾Ğ¿ Ğ½Ğ°Ğ´ 111500"

def test_parse_valid_signal_success():
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ ÑƒÑĞ¿ĞµÑˆĞ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°."""
    instruction = parse_pentagon_signal(VALID_SIGNAL_TEXT)
    
    assert instruction is not None
    assert instruction.side == 'short'
    assert instruction.entry_start == 109200.0
    assert instruction.entry_end == 110500.0
    assert instruction.stop_loss == 111500.0
    assert instruction.risk_pct == pytest.approx(0.005)
    assert instruction.size_fraction == pytest.approx(0.5)
    assert instruction.take_profits == [109000.0, 108800.0, 108600.0]

def test_parse_invalid_signal_returns_none():
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ°Ñ€ÑĞµÑ€ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ None Ğ´Ğ»Ñ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°."""
    instruction = parse_pentagon_signal(INVALID_SIGNAL_TEXT)
    assert instruction is None

def test_parse_empty_string_returns_none():
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸."""
    instruction = parse_pentagon_signal("")
    assert instruction is None

ğŸ”¹ File: tests/test_spring_model.py
----------------------------------------------
import pytest
import pandas as pd
import numpy as np
from spring_model import bounce_prob

@pytest.fixture
def synthetic_bars():
    # Synthetic data where mu=100, sigma=5
    # Lower BB = 100 - 2*5 = 90
    # Upper BB = 100 + 2*5 = 110
    np.random.seed(42)
    data = np.concatenate([np.random.normal(100, 5, 19), [100]])
    return pd.DataFrame({'close': data})

def test_long_bounce_strong(synthetic_bars):
    # Price is far below the lower BB, expecting high probability
    prob = bounce_prob(synthetic_bars, 'long', price=80, bb_std_dev=2.0)
    assert prob > 0.5
    assert prob <= 1.0

def test_long_bounce_zero(synthetic_bars):
    # Price is inside the bands, expecting zero probability
    prob = bounce_prob(synthetic_bars, 'long', price=95, bb_std_dev=2.0)
    assert prob == 0.0

def test_short_bounce_strong(synthetic_bars):
    # Price is far above the upper BB, expecting high probability
    prob = bounce_prob(synthetic_bars, 'short', price=120, bb_std_dev=2.0)
    assert prob > 0.5
    assert prob <= 1.0

def test_short_bounce_zero(synthetic_bars):
    # Price is inside the bands, expecting zero probability
    prob = bounce_prob(synthetic_bars, 'short', price=105, bb_std_dev=2.0)
    assert prob == 0.0

def test_edge_case_not_enough_data():
    bars = pd.DataFrame({'close': [100, 101]})
    prob = bounce_prob(bars, 'long', price=95, bb_window=20)
    assert prob == 0.0

def test_edge_case_zero_volatility():
    bars = pd.DataFrame({'close': [100] * 20})
    prob = bounce_prob(bars, 'long', price=95, bb_window=20)
    assert prob == 0.0

def test_invalid_side(synthetic_bars):
    with pytest.raises(ValueError):
        bounce_prob(synthetic_bars, 'sideways', price=100)

ğŸ”¹ File: tests/test_trade_logger.py
----------------------------------------------
# file: tests/test_trade_logger.py
import pytest
import json

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
from trade_logger import log_signal, log_trade_execution, log_event
from db_utils import get_db_connection

# Ğ­Ñ‚Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ° Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ñƒ clean_db ĞºĞ¾ Ğ²ÑĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ°Ğ¼ Ğ² Ñ„Ğ°Ğ¹Ğ»Ğµ
pytestmark = pytest.mark.usefixtures("setup_for_every_test")

# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ¸ĞºÑÑ‚ÑƒÑ€Ñƒ db_conn Ğ² Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ñ‚ĞµÑÑ‚Ğ°
def test_log_signal_creates_correct_record(): # REMOVE db_conn
    """
    Tests that log_signal correctly creates a record in the DB.
    """
    signal_data = {'symbol': 'BTCUSDT', 'side': 'long'}
    log_signal(signal_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = 'SIGNAL_RECEIVED'").fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    assert log_entry['event_type'] == 'SIGNAL_RECEIVED'
    payload = json.loads(log_entry['payload_json'])
    assert payload['symbol'] == 'BTCUSDT'


def test_log_successful_trade_execution(): # REMOVE db_conn
    """
    Tests logging of a successful order placement.
    """
    order_data = {'id': '123', 'error': None}
    log_trade_execution(order_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = 'ORDER_PLACED'").fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    assert log_entry['event_type'] == 'ORDER_PLACED'


def test_log_failed_trade_execution(): # REMOVE db_conn
    """
    Tests logging of a failed order placement.
    """
    order_data = {'error': 'InsufficientFunds'}
    log_trade_execution(order_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = 'ORDER_FAILED'").fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    assert log_entry['event_type'] == 'ORDER_FAILED'


def test_log_event_generic(): # REMOVE db_conn
    """Tests the generic log_event function."""
    event_type = "CUSTOM_TEST_EVENT"
    payload_data = {"key": "value"}
    log_event(event_type, payload_data)

    conn = get_db_connection()
    try:
        log_entry = conn.execute("SELECT * FROM trade_log WHERE event_type = ?", (event_type,)).fetchone()
    finally:
        conn.close()

    assert log_entry is not None
    payload = json.loads(log_entry['payload_json'])
    assert payload['key'] == "value"

ğŸ”¹ File: trade_logger.py
----------------------------------------------
# file: trade_logger.py
import json
from datetime import datetime, timezone

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ°Ñˆ ÑƒĞ½Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ½Ğ½ĞµĞºÑ‚Ğ¾Ñ€ Ğº Ğ‘Ğ”
from db_utils import get_db_connection

def log_event(event_type: str, payload: dict):
    """
    Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ»ÑĞ±Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ.
    Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµÑ‚ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ 'trade_log'.

    Args:
        event_type (str): Ğ¢Ğ¸Ğ¿ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 'SIGNAL_RECEIVED', 'ORDER_PLACED').
        payload (dict): Ğ¡Ğ»Ğ¾Ğ²Ğ°Ñ€ÑŒ Ñ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ¾ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¸.
    """
    try:
        conn = get_db_connection()
        
        # ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ğ²ÑĞµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ² payload Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞ¸, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº ÑĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
        # ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ² (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Decimal) Ğ¸ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½ÑĞ¸ÑÑ‚ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚ÑŒ.
        serializable_payload = {k: str(v) for k, v in payload.items()}
        payload_str = json.dumps(serializable_payload)

        record = {
            "timestamp_utc": datetime.now(timezone.utc).isoformat(timespec='microseconds'),
            "event_type": event_type,
            "payload_json": payload_str
        }
        
        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ `with conn:` Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğ° Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸
        with conn:
            conn.execute(
                "INSERT INTO trade_log (timestamp_utc, event_type, payload_json) VALUES (:timestamp_utc, :event_type, :payload_json)",
                record
            )
        
        print(f"[LOG] Event: {event_type} | Payload: {payload}")

    except Exception as e:
        # ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾ Ğ½Ğµ "ÑƒÑ€Ğ¾Ğ½Ğ¸Ñ‚ÑŒ" Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ, ĞµÑĞ»Ğ¸ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ.
        # ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ.
        print(f"[LOGGING_ERROR] Failed to log event '{event_type}'. Error: {e}")
    finally:
        if 'conn' in locals() and conn:
            conn.close()


def log_signal(signal: dict):
    """
    Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ-Ñ…ĞµĞ»Ğ¿ĞµÑ€ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ²Ñ…Ğ¾Ğ´ÑÑ‰ĞµĞ³Ğ¾ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°.
    """
    log_event("SIGNAL_RECEIVED", payload=signal)


def log_trade_execution(order_result: dict):
    """
    Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ-Ñ…ĞµĞ»Ğ¿ĞµÑ€ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°.
    ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ñ‚Ğ¸Ğ¿ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ (ÑƒÑĞ¿ĞµÑ…/Ğ½ĞµÑƒĞ´Ğ°Ñ‡Ğ°) Ğ¿Ğ¾ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ñ ĞºĞ»ÑÑ‡Ğ° 'error'.
    """
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ĞºĞ¾Ğ¿Ğ¸Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞºÑ‚, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ĞµÑ‰Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ
    payload = order_result.copy()
    
    # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ñ‚Ğ¸Ğ¿ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ
    # Ğ•ÑĞ»Ğ¸ Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğµ ĞµÑÑ‚ÑŒ ĞºĞ»ÑÑ‡ 'error' Ğ¸ Ğ¾Ğ½ Ğ½Ğµ None/Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹, ÑÑ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ ÑÑ‚Ğ¾ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¾Ğ¹
    if payload.get('error'):
        event_type = "ORDER_FAILED"
    else:
        event_type = "ORDER_PLACED"
        
    log_event(event_type, payload=payload)